"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/arcjet";
exports.ids = ["vendor-chunks/arcjet"];
exports.modules = {

/***/ "(rsc)/./node_modules/arcjet/index.js":
/*!**************************************!*\
  !*** ./node_modules/arcjet/index.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArcjetAllowDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetAllowDecision),\n/* harmony export */   ArcjetBotReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason),\n/* harmony export */   ArcjetChallengeDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetChallengeDecision),\n/* harmony export */   ArcjetConclusion: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetConclusion),\n/* harmony export */   ArcjetDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDecision),\n/* harmony export */   ArcjetDenyDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDenyDecision),\n/* harmony export */   ArcjetEdgeRuleReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEdgeRuleReason),\n/* harmony export */   ArcjetEmailReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason),\n/* harmony export */   ArcjetEmailType: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailType),\n/* harmony export */   ArcjetErrorDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision),\n/* harmony export */   ArcjetErrorReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason),\n/* harmony export */   ArcjetIpDetails: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetIpDetails),\n/* harmony export */   ArcjetMode: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetMode),\n/* harmony export */   ArcjetRateLimitAlgorithm: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitAlgorithm),\n/* harmony export */   ArcjetRateLimitReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason),\n/* harmony export */   ArcjetReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetReason),\n/* harmony export */   ArcjetRuleResult: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult),\n/* harmony export */   ArcjetRuleState: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleState),\n/* harmony export */   ArcjetSensitiveInfoReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetSensitiveInfoReason),\n/* harmony export */   ArcjetSensitiveInfoType: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetSensitiveInfoType),\n/* harmony export */   ArcjetShieldReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetShieldReason),\n/* harmony export */   ArcjetStack: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetStack),\n/* harmony export */   botCategories: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.botCategories),\n/* harmony export */   \"default\": () => (/* binding */ arcjet),\n/* harmony export */   detectBot: () => (/* binding */ detectBot),\n/* harmony export */   fixedWindow: () => (/* binding */ fixedWindow),\n/* harmony export */   protectSignup: () => (/* binding */ protectSignup),\n/* harmony export */   sensitiveInfo: () => (/* binding */ sensitiveInfo),\n/* harmony export */   shield: () => (/* binding */ shield),\n/* harmony export */   slidingWindow: () => (/* binding */ slidingWindow),\n/* harmony export */   tokenBucket: () => (/* binding */ tokenBucket),\n/* harmony export */   validateEmail: () => (/* binding */ validateEmail)\n/* harmony export */ });\n/* harmony import */ var _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @arcjet/protocol */ \"(rsc)/./node_modules/@arcjet/protocol/index.js\");\n/* harmony import */ var _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @arcjet/analyze */ \"(rsc)/./node_modules/@arcjet/analyze/index.js\");\n/* harmony import */ var _arcjet_duration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcjet/duration */ \"(rsc)/./node_modules/@arcjet/duration/index.js\");\n/* harmony import */ var _arcjet_headers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @arcjet/headers */ \"(rsc)/./node_modules/@arcjet/headers/index.js\");\n/* harmony import */ var _arcjet_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @arcjet/runtime */ \"(rsc)/./node_modules/@arcjet/runtime/index.js\");\n/* harmony import */ var _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @arcjet/stable-hash */ \"(rsc)/./node_modules/@arcjet/stable-hash/index.js\");\n/* harmony import */ var _arcjet_cache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @arcjet/cache */ \"(rsc)/./node_modules/@arcjet/cache/index.js\");\n\n\n\n\n\n\n\n\n\nfunction assert(condition, msg) {\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nfunction errorMessage(err) {\n    if (err) {\n        if (typeof err === \"string\") {\n            return err;\n        }\n        if (typeof err === \"object\" &&\n            \"message\" in err &&\n            typeof err.message === \"string\") {\n            return err.message;\n        }\n    }\n    return \"Unknown problem\";\n}\nconst knownFields = [\n    \"ip\",\n    \"method\",\n    \"protocol\",\n    \"host\",\n    \"path\",\n    \"headers\",\n    \"body\",\n    \"email\",\n    \"cookies\",\n    \"query\",\n];\nfunction isUnknownRequestProperty(key) {\n    return !knownFields.includes(key);\n}\nfunction isEmailType(type) {\n    return (type === \"FREE\" ||\n        type === \"DISPOSABLE\" ||\n        type === \"NO_MX_RECORDS\" ||\n        type === \"NO_GRAVATAR\" ||\n        type === \"INVALID\");\n}\nclass Performance {\n    log;\n    constructor(logger) {\n        this.log = logger;\n    }\n    // TODO(#2020): We should no-op this if loglevel is not `debug` to do less work\n    measure(label) {\n        const start = performance.now();\n        return () => {\n            const end = performance.now();\n            const diff = end - start;\n            this.log.debug(\"LATENCY %s: %sms\", label, diff.toFixed(3));\n        };\n    }\n}\nfunction toString(value) {\n    if (typeof value === \"string\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        return `${value}`;\n    }\n    if (typeof value === \"boolean\") {\n        return value ? \"true\" : \"false\";\n    }\n    return \"<unsupported value>\";\n}\n// This is the Symbol that Vercel defines in their infrastructure to access the\n// Context (where available). The Context can contain the `waitUntil` function.\n// https://github.com/vercel/vercel/blob/930d7fb892dc26f240f2b950d963931c45e1e661/packages/functions/src/get-context.ts#L6\nconst SYMBOL_FOR_REQ_CONTEXT = Symbol.for(\"@vercel/request-context\");\nfunction lookupWaitUntil() {\n    const fromSymbol = globalThis;\n    if (typeof fromSymbol[SYMBOL_FOR_REQ_CONTEXT] === \"object\" &&\n        fromSymbol[SYMBOL_FOR_REQ_CONTEXT] !== null &&\n        \"get\" in fromSymbol[SYMBOL_FOR_REQ_CONTEXT] &&\n        typeof fromSymbol[SYMBOL_FOR_REQ_CONTEXT].get === \"function\") {\n        const vercelCtx = fromSymbol[SYMBOL_FOR_REQ_CONTEXT].get();\n        if (typeof vercelCtx === \"object\" &&\n            vercelCtx !== null &&\n            \"waitUntil\" in vercelCtx &&\n            typeof vercelCtx.waitUntil === \"function\") {\n            return vercelCtx.waitUntil;\n        }\n    }\n}\nfunction toAnalyzeRequest(request) {\n    const headers = {};\n    if (typeof request.headers !== \"undefined\") {\n        for (const [key, value] of request.headers.entries()) {\n            headers[key] = value;\n        }\n    }\n    return {\n        ...request,\n        headers,\n    };\n}\nfunction extraProps(details) {\n    const extra = new Map();\n    for (const [key, value] of Object.entries(details)) {\n        if (isUnknownRequestProperty(key)) {\n            extra.set(key, toString(value));\n        }\n    }\n    return Object.fromEntries(extra.entries());\n}\nfunction createTypeValidator(...types) {\n    return (key, value) => {\n        const typeOfValue = typeof value;\n        if (!types.includes(typeOfValue)) {\n            if (types.length === 1) {\n                throw new Error(`invalid type for \\`${key}\\` - expected ${types[0]}`);\n            }\n            else {\n                throw new Error(`invalid type for \\`${key}\\` - expected one of ${types.join(\", \")}`);\n            }\n        }\n        else {\n            return false;\n        }\n    };\n}\nfunction createValueValidator(\n// This uses types to ensure we have at least 2 values\n...values) {\n    return (key, value) => {\n        // We cast the values to unknown because the optionValue isn't known but\n        // we only want to use `values` on string enumerations\n        if (!values.includes(value)) {\n            throw new Error(`invalid value for \\`${key}\\` - expected one of ${values.map((value) => `'${value}'`).join(\", \")}`);\n        }\n    };\n}\nfunction createArrayValidator(validate) {\n    return (key, value) => {\n        if (Array.isArray(value)) {\n            for (const [idx, item] of value.entries()) {\n                validate(`${key}[${idx}]`, item);\n            }\n        }\n        else {\n            throw new Error(`invalid type for \\`${key}\\` - expected an array`);\n        }\n    };\n}\nfunction createValidator({ rule, validations, }) {\n    return (options) => {\n        for (const { key, validate, required } of validations) {\n            if (required && !Object.hasOwn(options, key)) {\n                throw new Error(`\\`${rule}\\` options error: \\`${key}\\` is required`);\n            }\n            const value = options[key];\n            // The `required` flag is checked above, so these should only be validated\n            // if the value is not undefined.\n            if (typeof value !== \"undefined\") {\n                try {\n                    validate(key, value);\n                }\n                catch (err) {\n                    throw new Error(`\\`${rule}\\` options error: ${errorMessage(err)}`);\n                }\n            }\n        }\n    };\n}\nconst validateString = createTypeValidator(\"string\");\nconst validateNumber = createTypeValidator(\"number\");\nconst validateBoolean = createTypeValidator(\"boolean\");\nconst validateFunction = createTypeValidator(\"function\");\nconst validateStringOrNumber = createTypeValidator(\"string\", \"number\");\nconst validateStringArray = createArrayValidator(validateString);\nconst validateMode = createValueValidator(\"LIVE\", \"DRY_RUN\");\nconst validateEmailTypes = createArrayValidator(createValueValidator(\"DISPOSABLE\", \"FREE\", \"NO_MX_RECORDS\", \"NO_GRAVATAR\", \"INVALID\"));\nconst validateTokenBucketOptions = createValidator({\n    rule: \"tokenBucket\",\n    validations: [\n        {\n            key: \"mode\",\n            required: false,\n            validate: validateMode,\n        },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"refillRate\", required: true, validate: validateNumber },\n        { key: \"interval\", required: true, validate: validateStringOrNumber },\n        { key: \"capacity\", required: true, validate: validateNumber },\n    ],\n});\nconst validateFixedWindowOptions = createValidator({\n    rule: \"fixedWindow\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"max\", required: true, validate: validateNumber },\n        { key: \"window\", required: true, validate: validateStringOrNumber },\n    ],\n});\nconst validateSlidingWindowOptions = createValidator({\n    rule: \"slidingWindow\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"max\", required: true, validate: validateNumber },\n        { key: \"interval\", required: true, validate: validateStringOrNumber },\n    ],\n});\nconst validateSensitiveInfoOptions = createValidator({\n    rule: \"sensitiveInfo\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"allow\", required: false, validate: validateStringArray },\n        { key: \"deny\", required: false, validate: validateStringArray },\n        { key: \"contextWindowSize\", required: false, validate: validateNumber },\n        { key: \"detect\", required: false, validate: validateFunction },\n    ],\n});\nconst validateEmailOptions = createValidator({\n    rule: \"validateEmail\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"block\", required: false, validate: validateEmailTypes },\n        { key: \"allow\", required: false, validate: validateEmailTypes },\n        { key: \"deny\", required: false, validate: validateEmailTypes },\n        {\n            key: \"requireTopLevelDomain\",\n            required: false,\n            validate: validateBoolean,\n        },\n        { key: \"allowDomainLiteral\", required: false, validate: validateBoolean },\n    ],\n});\nconst validateBotOptions = createValidator({\n    rule: \"detectBot\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"allow\", required: false, validate: validateStringArray },\n        { key: \"deny\", required: false, validate: validateStringArray },\n    ],\n});\nconst validateShieldOptions = createValidator({\n    rule: \"shield\",\n    validations: [{ key: \"mode\", required: false, validate: validateMode }],\n});\nconst Priority = {\n    SensitiveInfo: 1,\n    Shield: 2,\n    RateLimit: 3,\n    BotDetection: 4,\n    EmailValidation: 5,\n};\nfunction isRateLimitRule(rule) {\n    return rule.type === \"RATE_LIMIT\";\n}\n/**\n * Arcjet token bucket rate limiting rule. Applying this rule sets a token\n * bucket rate limit.\n *\n * This algorithm is based on a bucket filled with a specific number of tokens.\n * Each request withdraws some amount of tokens from the bucket and the bucket\n * is refilled at a fixed rate. Once the bucket is empty, the client is blocked\n * until the bucket refills.\n *\n * This algorithm is useful when you want to allow clients to make a burst of\n * requests and then still be able to make requests at a slower rate.\n *\n * @param {TokenBucketRateLimitOptions} options - The options for the token\n * bucket rate limiting rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block requests when the rate limit is\n * exceeded, and `\"DRY_RUN\"` will allow all requests while still providing\n * access to the rule results. Defaults to `\"DRY_RUN\"` if not specified.\n * @param {number} options.refillRate - The number of tokens to add to the\n * bucket at each interval. For example, if you set the interval to 60 and the\n * refill rate to 10, the bucket will refill 10 tokens every 60 seconds.\n * @param {string | number} options.interval - The time interval for the refill\n * rate. This can be a string like `\"60s\"` for 60 seconds, `\"1h45m\"` for 1 hour\n * and 45 minutes, or a number like `60` for 60 seconds. Valid string time units\n * are:\n * - `s` for seconds.\n * - `m` for minutes.\n * - `h` for hours.\n * - `d` for days.\n * @param {number} options.capacity - The maximum number of tokens the bucket\n * can hold. The bucket starts at full capacity and will refill until it hits\n * the capacity.\n * @returns {Primitive} The token bucket rule to provide to the SDK in the\n * `rules` option.\n *\n * @example\n * ```ts\n * tokenBucket({ mode: \"LIVE\", refillRate: 10, interval: \"60s\", capacity: 100 });\n * ```\n * @example\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     tokenBucket({\n *       mode: \"LIVE\",\n *       refillRate: 10,\n *       interval: \"60s\",\n *       capacity: 100,\n *     })\n *   ],\n * });\n * ```\n * @link https://docs.arcjet.com/rate-limiting/concepts\n * @link https://docs.arcjet.com/rate-limiting/algorithms#token-bucket\n * @link https://docs.arcjet.com/rate-limiting/reference\n */\nfunction tokenBucket(options) {\n    validateTokenBucketOptions(options);\n    const type = \"RATE_LIMIT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const refillRate = options.refillRate;\n    const interval = _arcjet_duration__WEBPACK_IMPORTED_MODULE_2__.parse(options.interval);\n    const capacity = options.capacity;\n    const rule = {\n        type,\n        version,\n        priority: Priority.RateLimit,\n        mode,\n        characteristics,\n        algorithm: \"TOKEN_BUCKET\",\n        refillRate,\n        interval,\n        capacity,\n        validate() { },\n        async protect(context, details) {\n            const localCharacteristics = characteristics ?? context.characteristics;\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"algorithm\", \"TOKEN_BUCKET\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"characteristics\", localCharacteristics), \n            // Match is deprecated so it is always an empty string in the newest SDKs\n            _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"match\", \"\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"refillRate\", refillRate), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"interval\", interval), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"capacity\", capacity));\n            const analyzeContext = {\n                characteristics: localCharacteristics,\n                log: context.log,\n            };\n            const fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(analyzeContext, toAnalyzeRequest(details));\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached && cached.reason.isRateLimit()) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    // We rebuild the `ArcjetRateLimitReason` because we need to adjust\n                    // the `reset` based on the current time-to-live\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                        max: cached.reason.max,\n                        remaining: cached.reason.remaining,\n                        reset: ttl,\n                        window: cached.reason.window,\n                        resetTime: cached.reason.resetTime,\n                    }),\n                });\n            }\n            return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                ruleId,\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                    max: 0,\n                    remaining: 0,\n                    reset: 0,\n                    window: 0,\n                    resetTime: new Date(),\n                }),\n            });\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet fixed window rate limiting rule. Applying this rule sets a fixed\n * window rate limit which tracks the number of requests made by a client over a\n * fixed time window.\n *\n * This is the simplest algorithm. It tracks the number of requests made by a\n * client over a fixed time window e.g. 60 seconds. If the client exceeds the\n * limit, they are blocked until the window expires.\n *\n * This algorithm is useful when you want to apply a simple fixed limit in a\n * fixed time window. For example, a simple limit on the total number of\n * requests a client can make. However, it can be susceptible to the stampede\n * problem where a client makes a burst of requests at the start of a window and\n * then is blocked for the rest of the window. The sliding window algorithm can\n * be used to avoid this.\n *\n * @param {FixedWindowRateLimitOptions} options - The options for the fixed\n * window rate limiting rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block requests when the rate limit is\n * exceeded, and `\"DRY_RUN\"` will allow all requests while still providing\n * access to the rule results. Defaults to `\"DRY_RUN\"` if not specified.\n * @param {string | number} options.window - The fixed time window. This can be\n * a string like `\"60s\"` for 60 seconds, `\"1h45m\"` for 1 hour and 45 minutes, or\n * a number like `60` for 60 seconds. Valid string time units are:\n * - `s` for seconds.\n * - `m` for minutes.\n * - `h` for hours.\n * - `d` for days.\n * @param {number} options.max - The maximum number of requests allowed in the\n * fixed time window.\n * @returns {Primitive} The fixed window rule to provide to the SDK in the\n * `rules` option.\n *\n * @example\n * ```ts\n * fixedWindow({ mode: \"LIVE\", window: \"60s\", max: 100 });\n * ```\n * @example\n * ```ts\n * const aj = arcjet({\n *    key: process.env.ARCJET_KEY,\n *   rules: [\n *     fixedWindow({\n *       mode: \"LIVE\",\n *       window: \"60s\",\n *       max: 100,\n *     })\n *   ],\n * });\n * ```\n * @link https://docs.arcjet.com/rate-limiting/concepts\n * @link https://docs.arcjet.com/rate-limiting/algorithms#fixed-window\n * @link https://docs.arcjet.com/rate-limiting/reference\n */\nfunction fixedWindow(options) {\n    validateFixedWindowOptions(options);\n    const type = \"RATE_LIMIT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const max = options.max;\n    const window = _arcjet_duration__WEBPACK_IMPORTED_MODULE_2__.parse(options.window);\n    const rule = {\n        type,\n        version,\n        priority: Priority.RateLimit,\n        mode,\n        characteristics,\n        algorithm: \"FIXED_WINDOW\",\n        max,\n        window,\n        validate() { },\n        async protect(context, details) {\n            const localCharacteristics = characteristics ?? context.characteristics;\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"algorithm\", \"FIXED_WINDOW\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"characteristics\", localCharacteristics), \n            // Match is deprecated so it is always an empty string in the newest SDKs\n            _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"match\", \"\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"max\", max), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"window\", window));\n            const analyzeContext = {\n                characteristics: localCharacteristics,\n                log: context.log,\n            };\n            const fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(analyzeContext, toAnalyzeRequest(details));\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached && cached.reason.isRateLimit()) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    // We rebuild the `ArcjetRateLimitReason` because we need to adjust\n                    // the `reset` based on the current time-to-live\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                        max: cached.reason.max,\n                        remaining: cached.reason.remaining,\n                        reset: ttl,\n                        window: cached.reason.window,\n                        resetTime: cached.reason.resetTime,\n                    }),\n                });\n            }\n            return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                ruleId,\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                    max: 0,\n                    remaining: 0,\n                    reset: 0,\n                    window: 0,\n                }),\n            });\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet sliding window rate limiting rule. Applying this rule sets a sliding\n * window rate limit which tracks the number of requests made by a client over a\n * sliding window so that the window moves with time.\n *\n * This algorithm is useful to avoid the stampede problem of the fixed window.\n * It provides smoother rate limiting over time and can prevent a client from\n * making a burst of requests at the start of a window and then being blocked\n * for the rest of the window.\n *\n * @param {SlidingWindowRateLimitOptions} options - The options for the sliding\n * window rate limiting rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block requests when the rate limit is\n * exceeded, and `\"DRY_RUN\"` will allow all requests while still providing\n * access to the rule results. Defaults to `\"DRY_RUN\"` if not specified.\n * @param {string | number} options.interval - The time interval for the rate\n * limit. This can be a string like `\"60s\"` for 60 seconds, `\"1h45m\"` for 1 hour\n * and 45 minutes, or a number like `60` for 60 seconds. Valid string time units\n * are:\n * - `s` for seconds.\n * - `m` for minutes.\n * - `h` for hours.\n * - `d` for days.\n * @param {number} options.max - The maximum number of requests allowed in the\n * sliding time window.\n * @returns {Primitive} The sliding window rule to provide to the SDK in the\n * `rules` option.\n *\n * @example\n * ```ts\n * slidingWindow({ mode: \"LIVE\", interval: \"60s\", max: 100 });\n * ```\n * @example\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     slidingWindow({\n *       mode: \"LIVE\",\n *       interval: \"60s\",\n *       max: 100,\n *     })\n *   ],\n * });\n * ```\n * @link https://docs.arcjet.com/rate-limiting/concepts\n * @link https://docs.arcjet.com/rate-limiting/algorithms#sliding-window\n * @link https://docs.arcjet.com/rate-limiting/reference\n */\nfunction slidingWindow(options) {\n    validateSlidingWindowOptions(options);\n    const type = \"RATE_LIMIT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const max = options.max;\n    const interval = _arcjet_duration__WEBPACK_IMPORTED_MODULE_2__.parse(options.interval);\n    const rule = {\n        type,\n        version,\n        priority: Priority.RateLimit,\n        mode,\n        characteristics,\n        algorithm: \"SLIDING_WINDOW\",\n        max,\n        interval,\n        validate() { },\n        async protect(context, details) {\n            const localCharacteristics = characteristics ?? context.characteristics;\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"algorithm\", \"SLIDING_WINDOW\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"characteristics\", localCharacteristics), \n            // Match is deprecated so it is always an empty string in the newest SDKs\n            _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"match\", \"\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"max\", max), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"interval\", interval));\n            const analyzeContext = {\n                characteristics: localCharacteristics,\n                log: context.log,\n            };\n            const fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(analyzeContext, toAnalyzeRequest(details));\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached && cached.reason.isRateLimit()) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    // We rebuild the `ArcjetRateLimitReason` because we need to adjust\n                    // the `reset` based on the current time-to-live\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                        max: cached.reason.max,\n                        remaining: cached.reason.remaining,\n                        reset: ttl,\n                        window: cached.reason.window,\n                        resetTime: cached.reason.resetTime,\n                    }),\n                });\n            }\n            return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                ruleId,\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                    max: 0,\n                    remaining: 0,\n                    reset: 0,\n                    window: 0,\n                }),\n            });\n        },\n    };\n    return [rule];\n}\nfunction protocolSensitiveInfoEntitiesToAnalyze(entity) {\n    if (typeof entity !== \"string\") {\n        throw new Error(\"invalid entity type\");\n    }\n    if (entity === \"EMAIL\") {\n        return { tag: \"email\" };\n    }\n    if (entity === \"PHONE_NUMBER\") {\n        return { tag: \"phone-number\" };\n    }\n    if (entity === \"IP_ADDRESS\") {\n        return { tag: \"ip-address\" };\n    }\n    if (entity === \"CREDIT_CARD_NUMBER\") {\n        return { tag: \"credit-card-number\" };\n    }\n    return {\n        tag: \"custom\",\n        val: entity,\n    };\n}\nfunction analyzeSensitiveInfoEntitiesToString(entity) {\n    if (entity.tag === \"email\") {\n        return \"EMAIL\";\n    }\n    if (entity.tag === \"ip-address\") {\n        return \"IP_ADDRESS\";\n    }\n    if (entity.tag === \"credit-card-number\") {\n        return \"CREDIT_CARD_NUMBER\";\n    }\n    if (entity.tag === \"phone-number\") {\n        return \"PHONE_NUMBER\";\n    }\n    return entity.val;\n}\nfunction convertAnalyzeDetectedSensitiveInfoEntity(detectedEntities) {\n    return detectedEntities.map((detectedEntity) => {\n        return {\n            ...detectedEntity,\n            identifiedType: analyzeSensitiveInfoEntitiesToString(detectedEntity.identifiedType),\n        };\n    });\n}\n/**\n * Arcjet sensitive information detection rule. Applying this rule protects\n * against clients sending you sensitive information such as personally\n * identifiable information (PII) that you do not wish to handle. The rule runs\n * entirely locally so no data ever leaves your environment.\n *\n * This rule includes built-in detections for email addresses, credit/debit card\n * numbers, IP addresses, and phone numbers. You can also provide a custom\n * detection function to identify additional sensitive information.\n *\n * @param {SensitiveInfoOptions} options - The options for the sensitive\n * information detection rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block requests when any of the\n * configured sensitive information types are detected, and `\"DRY_RUN\"` will\n * allow all requests while still providing access to the rule results. Defaults\n * to `\"DRY_RUN\"` if not specified.\n * @param {Array<ArcjetSensitiveInfoType>} options.deny - The list of sensitive\n * information types to deny. If provided, the sensitive information types in\n * this list will be denied. You may only provide either `allow` or `deny`, not\n * both. Specify one or more of the following:\n *\n * - `\"EMAIL\"`\n * - `\"PHONE_NUMBER\"`\n * - `\"IP_ADDRESS\"`\n * - `\"CREDIT_CARD_NUMBER\"`\n * @param {Array<ArcjetSensitiveInfoType>} options.allow - The list of sensitive\n * information types to allow. If provided, types in this list will be allowed\n * and all others will be denied. You may only provide either `allow` or `deny`,\n * not both. The same options apply as for `deny`.\n * @param {DetectSensitiveInfoEntities} options.detect - A custom detection\n * function. The function will take a list of tokens and must return a list of\n * either `undefined`, if the corresponding token in the input list is not\n * sensitive, or the name of the entity if it does match. The number of tokens\n * that are provided to the function is controlled by the `contextWindowSize`\n * option, which defaults to `1`. If you need additional context to perform\n * detections then you can increase this value.\n * @param {number} options.contextWindowSize - The number of tokens to provide\n * to the custom detection function. This defaults to 1 if not specified.\n * @returns {Primitive} The sensitive information rule to provide to the SDK in\n * the `rules` option.\n *\n * @example\n * ```ts\n * sensitiveInfo({ mode: \"LIVE\", deny: [\"EMAIL\"] });\n * ```\n * @example\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     sensitiveInfo({\n *       mode: \"LIVE\",\n *       deny: [\"EMAIL\"],\n *     })\n *   ],\n * });\n * ```\n * @example\n * Custom detection function:\n * ```ts\n * function detectDash(tokens: string[]): Array<\"CONTAINS_DASH\" | undefined> {\n *   return tokens.map((token) => {\n *     if (token.includes(\"-\")) {\n *       return \"CONTAINS_DASH\";\n *     }\n *   });\n * }\n *\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     sensitiveInfo({\n *       mode: \"LIVE\",\n *       deny: [\"EMAIL\", \"CONTAINS_DASH\"],\n *       detect: detectDash,\n *       contextWindowSize: 2,\n *     })\n *   ],\n * });\n * ```\n * @link https://docs.arcjet.com/sensitive-info/concepts\n * @link https://docs.arcjet.com/sensitive-info/reference\n */\nfunction sensitiveInfo(options) {\n    validateSensitiveInfoOptions(options);\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`sensitiveInfo` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\") {\n        throw new Error(\"`sensitiveInfo` options error: either `allow` or `deny` must be specified\");\n    }\n    const type = \"SENSITIVE_INFO\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow || [];\n    const deny = options.deny || [];\n    const rule = {\n        version,\n        priority: Priority.SensitiveInfo,\n        type,\n        mode,\n        allow,\n        deny,\n        validate(context, details) { },\n        async protect(context, details) {\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"allow\", allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"deny\", deny));\n            const { fingerprint } = context;\n            // No cache is implemented here because the fingerprint can be the same\n            // while the request body changes. This is also why the `sensitiveInfo`\n            // rule results always have a `ttl` of 0.\n            const body = await context.getBody();\n            if (typeof body === \"undefined\") {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state: \"NOT_RUN\",\n                    conclusion: \"ERROR\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"Couldn't read the body of the request to perform sensitive info identification.\"),\n                });\n            }\n            let convertedDetect = undefined;\n            if (typeof options.detect !== \"undefined\") {\n                const detect = options.detect;\n                convertedDetect = (tokens) => {\n                    return detect(tokens)\n                        .filter((e) => typeof e !== \"undefined\")\n                        .map(protocolSensitiveInfoEntitiesToAnalyze);\n                };\n            }\n            let entitiesTag = \"allow\";\n            let entitiesVal = [];\n            if (Array.isArray(options.allow)) {\n                entitiesTag = \"allow\";\n                entitiesVal = options.allow\n                    .filter((e) => typeof e !== \"undefined\")\n                    .map(protocolSensitiveInfoEntitiesToAnalyze);\n            }\n            if (Array.isArray(options.deny)) {\n                entitiesTag = \"deny\";\n                entitiesVal = options.deny\n                    .filter((e) => typeof e !== \"undefined\")\n                    .map(protocolSensitiveInfoEntitiesToAnalyze);\n            }\n            const entities = {\n                tag: entitiesTag,\n                val: entitiesVal,\n            };\n            const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.detectSensitiveInfo(context, body, entities, options.contextWindowSize || 1, convertedDetect);\n            const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n            const reason = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetSensitiveInfoReason({\n                denied: convertAnalyzeDetectedSensitiveInfoEntity(result.denied),\n                allowed: convertAnalyzeDetectedSensitiveInfoEntity(result.allowed),\n            });\n            if (result.denied.length === 0) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"ALLOW\",\n                    reason,\n                });\n            }\n            else {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"DENY\",\n                    reason,\n                });\n            }\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet email validation rule. Applying this rule allows you to validate &\n * verify an email address.\n *\n * The first step of the analysis is to validate the email address syntax. This\n * runs locally within the SDK and validates the email address is in the correct\n * format. If the email syntax is valid, the SDK will pass the email address to\n * the Arcjet cloud API to verify the email address. This performs several\n * checks, depending on the rule configuration.\n *\n * @param {EmailOptions} options - The options for the email validation rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block email addresses based on the\n * configuration, and `\"DRY_RUN\"` will allow all requests while still providing\n * access to the rule results. Defaults to `\"DRY_RUN\"` if not specified.\n * @param {Array<ArcjetEmailType>} options.deny - The list of email types to\n * deny. If provided, the email types in this list will be denied. You may only\n * provide either `allow` or `deny`, not both. Specify one or more of the\n * following:\n *\n * - `\"DISPOSABLE\"` - Disposable email addresses.\n * - `\"FREE\"` - Free email addresses.\n * - `\"NO_MX_RECORDS\"` - Email addresses with no MX records.\n * - `\"NO_GRAVATAR\"` - Email addresses with no Gravatar.\n * - `\"INVALID\"` - Invalid email addresses.\n *\n * @param {Array<ArcjetEmailType>} options.allow - The list of email types to\n * allow. If provided, email addresses in this list will be allowed and all\n * others will be denied. You may only provide either `allow` or `deny`, not\n * both. The same options apply as for `deny`.\n * @returns {Primitive} The email rule to provide to the SDK in the `rules`\n * option.\n *\n * @example\n * ```ts\n * validateEmail({ mode: \"LIVE\", deny: [\"DISPOSABLE\", \"INVALID\"] });\n * ```\n * @example\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     validateEmail({\n *       mode: \"LIVE\",\n *       deny: [\"DISPOSABLE\", \"INVALID\"]\n *     })\n *   ],\n * });\n * ```\n * @link https://docs.arcjet.com/email-validation/concepts\n * @link https://docs.arcjet.com/email-validation/reference\n */\nfunction validateEmail(options) {\n    validateEmailOptions(options);\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`validateEmail` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.block !== \"undefined\") {\n        throw new Error(\"`validateEmail` options error: `allow` and `block` cannot be provided together\");\n    }\n    if (typeof options.deny !== \"undefined\" &&\n        typeof options.block !== \"undefined\") {\n        throw new Error(\"`validateEmail` options error: `deny` and `block` cannot be provided together, `block` is now deprecated so `deny` should be preferred.\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\" &&\n        typeof options.block === \"undefined\") {\n        throw new Error(\"`validateEmail` options error: either `allow` or `deny` must be specified\");\n    }\n    const type = \"EMAIL\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow ?? [];\n    const deny = options.deny ?? options.block ?? [];\n    const requireTopLevelDomain = options.requireTopLevelDomain ?? true;\n    const allowDomainLiteral = options.allowDomainLiteral ?? false;\n    let config = {\n        tag: \"deny-email-validation-config\",\n        val: {\n            requireTopLevelDomain,\n            allowDomainLiteral,\n            deny: [],\n        },\n    };\n    if (typeof options.allow !== \"undefined\") {\n        config = {\n            tag: \"allow-email-validation-config\",\n            val: {\n                requireTopLevelDomain,\n                allowDomainLiteral,\n                allow: options.allow,\n            },\n        };\n    }\n    if (typeof options.deny !== \"undefined\") {\n        config = {\n            tag: \"deny-email-validation-config\",\n            val: {\n                requireTopLevelDomain,\n                allowDomainLiteral,\n                deny: options.deny,\n            },\n        };\n    }\n    if (typeof options.block !== \"undefined\") {\n        config = {\n            tag: \"deny-email-validation-config\",\n            val: {\n                requireTopLevelDomain,\n                allowDomainLiteral,\n                deny: options.block,\n            },\n        };\n    }\n    const rule = {\n        version,\n        priority: Priority.EmailValidation,\n        type,\n        mode,\n        allow,\n        deny,\n        requireTopLevelDomain,\n        allowDomainLiteral,\n        validate(context, details) {\n            assert(typeof details.email !== \"undefined\", \"ValidateEmail requires `email` to be set.\");\n        },\n        async protect(context, { email }) {\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"allow\", allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"deny\", deny), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.bool(\"requireTopLevelDomain\", requireTopLevelDomain), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.bool(\"allowDomainLiteral\", allowDomainLiteral));\n            const { fingerprint } = context;\n            // No cache is implemented here because the fingerprint can be the same\n            // while the email changes. This is also why the `email` rule results\n            // always have a `ttl` of 0.\n            const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.isValidEmail(context, email, config);\n            const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n            if (result.validity === \"valid\") {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"ALLOW\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason({ emailTypes: [] }),\n                });\n            }\n            else {\n                const typedEmailTypes = result.blocked.filter(isEmailType);\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"DENY\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason({\n                        emailTypes: typedEmailTypes,\n                    }),\n                });\n            }\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet bot detection rule. Applying this rule allows you to manage traffic by\n * automated clients and bots.\n *\n * Bots can be good (such as search engine crawlers or monitoring agents) or bad\n * (such as scrapers or automated scripts). Arcjet allows you to configure which\n * bots you want to allow or deny by specific bot names e.g. curl, as well as by\n * category e.g. search engine bots.\n *\n * Bots are detected based on various signals such as the user agent, IP\n * address, DNS records, and more.\n *\n * @param {BotOptions} options - The options for the bot rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block detected bots, and `\"DRY_RUN\"`\n * will allow all requests while still providing access to the rule results.\n * Defaults to `\"DRY_RUN\"` if not specified.\n * @param {Array<ArcjetWellKnownBot | ArcjetBotCategory>} options.allow - The\n * list of bots to allow. If provided, only the bots in this list will be\n * allowed and any other detected bot will be denied. If empty, all bots will be\n * denied. You may only provide either `allow` or `deny`, not both. You can use\n * specific bots e.g. `\"CURL\"` will allow the default user-agent of the `curl`\n * tool. You can also use categories e.g. `\"CATEGORY:SEARCH_ENGINE\"` will allow\n * all search engine bots. See\n * https://docs.arcjet.com/bot-protection/identifying-bots for the full list of\n * bots and categories.\n * @param {Array<ArcjetWellKnownBot | ArcjetBotCategory>} options.deny - The\n * list of bots to deny. If provided, the bots in this list will be denied and\n * all other detected bots will be allowed. You may only provide either `allow`\n * or `deny`, not both. The same options apply as for `allow`.\n * @returns {Primitive} The bot rule to provide to the SDK in the `rules`\n * option.\n *\n * @example\n * Allows search engine bots and curl, denies all other bots\n *\n * ```ts\n * detectBot({ mode: \"LIVE\", allow: [\"CATEGORY:SEARCH_ENGINE\", \"CURL\"] });\n * ```\n * @example\n * Allows search engine bots and curl, denies all other bots\n *\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     detectBot({\n *       mode: \"LIVE\",\n *       allow: [\"CATEGORY:SEARCH_ENGINE\", \"CURL\"]\n *     })\n *   ],\n * });\n * ```\n * @example\n * Denies AI crawlers, allows all other bots\n *\n * ```ts\n * detectBot({ mode: \"LIVE\", deny: [\"CATEGORY:AI\"] });\n * ```\n * @example\n * Denies AI crawlers, allows all other bots\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     detectBot({\n *       mode: \"LIVE\",\n *       deny: [\"CATEGORY:AI\"]\n *     })\n *   ],\n * });\n * ```\n * @link https://docs.arcjet.com/bot-protection/concepts\n * @link https://docs.arcjet.com/bot-protection/identifying-bots\n * @link https://docs.arcjet.com/bot-protection/reference\n */\nfunction detectBot(options) {\n    validateBotOptions(options);\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`detectBot` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\") {\n        throw new Error(\"`detectBot` options error: either `allow` or `deny` must be specified\");\n    }\n    const type = \"BOT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow ?? [];\n    const deny = options.deny ?? [];\n    let config = {\n        tag: \"allowed-bot-config\",\n        val: {\n            entities: [],\n            skipCustomDetect: true,\n        },\n    };\n    if (typeof options.allow !== \"undefined\") {\n        config = {\n            tag: \"allowed-bot-config\",\n            val: {\n                entities: options.allow,\n                skipCustomDetect: true,\n            },\n        };\n    }\n    if (typeof options.deny !== \"undefined\") {\n        config = {\n            tag: \"denied-bot-config\",\n            val: {\n                entities: options.deny,\n                skipCustomDetect: true,\n            },\n        };\n    }\n    const rule = {\n        version,\n        priority: Priority.BotDetection,\n        type,\n        mode,\n        allow,\n        deny,\n        validate(context, details) {\n            if (typeof details.headers === \"undefined\") {\n                throw new Error(\"bot detection requires `headers` to be set\");\n            }\n            if (typeof details.headers.has !== \"function\") {\n                throw new Error(\"bot detection requires `headers` to extend `Headers`\");\n            }\n            if (!details.headers.has(\"user-agent\")) {\n                throw new Error(\"bot detection requires user-agent header\");\n            }\n        },\n        /**\n         * Attempts to call the bot detection on the headers.\n         */\n        async protect(context, request) {\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"allow\", allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"deny\", deny));\n            const { fingerprint } = context;\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    reason: cached.reason,\n                });\n            }\n            const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.detectBot(context, toAnalyzeRequest(request), config);\n            const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n            // If this is a bot and of a type that we want to block, then block!\n            if (result.denied.length > 0) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 60,\n                    state,\n                    conclusion: \"DENY\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason({\n                        allowed: result.allowed,\n                        denied: result.denied,\n                        verified: result.verified,\n                        spoofed: result.spoofed,\n                    }),\n                });\n            }\n            else {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"ALLOW\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason({\n                        allowed: result.allowed,\n                        denied: result.denied,\n                        verified: result.verified,\n                        spoofed: result.spoofed,\n                    }),\n                });\n            }\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet Shield WAF rule. Applying this rule protects your application against\n * common attacks, including the OWASP Top 10.\n *\n * The Arcjet Shield WAF analyzes every request to your application to detect\n * suspicious activity. Once a certain suspicion threshold is reached,\n * subsequent requests from that client are blocked for a period of time.\n *\n * @param {ShieldOptions} options - The options for the Shield rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block suspicious requests, and\n * `\"DRY_RUN\"` will allow all requests while still providing access to the rule\n * results. Defaults to `\"DRY_RUN\"` if not specified.\n * @returns {Primitive} The Shield rule to provide to the SDK in the `rules`\n * option.\n *\n * @example\n * ```ts\n * shield({ mode: \"LIVE\" });\n * ```\n * @example\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [shield({ mode: \"LIVE\" })],\n * });\n * ```\n * @link https://docs.arcjet.com/shield/concepts\n * @link https://docs.arcjet.com/shield/reference\n */\nfunction shield(options) {\n    validateShieldOptions(options);\n    const type = \"SHIELD\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const rule = {\n        type,\n        version,\n        priority: Priority.Shield,\n        mode,\n        validate() { },\n        async protect(context, details) {\n            // TODO(#1989): Prefer characteristics defined on rule once available\n            const localCharacteristics = context.characteristics;\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"characteristics\", localCharacteristics));\n            const analyzeContext = {\n                characteristics: localCharacteristics,\n                log: context.log,\n            };\n            const fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(analyzeContext, toAnalyzeRequest(details));\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    reason: cached.reason,\n                });\n            }\n            return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                ruleId,\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetShieldReason({\n                    shieldTriggered: false,\n                }),\n            });\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet signup form protection rule. Applying this rule combines rate\n * limiting, bot protection, and email validation to protect your signup forms\n * from abuse. Using this rule will configure the following:\n *\n * - Rate limiting - signup forms are a common target for bots. Arcjet’s rate\n *   limiting helps to prevent bots and other automated or malicious clients\n *   from submitting your signup form too many times in a short period of time.\n * - Bot protection - signup forms are usually exclusively used by humans, which\n *   means that any automated submissions to the form are likely to be\n *   fraudulent.\n * - Email validation - email addresses should be validated to ensure the signup\n *   is coming from a legitimate user with a real email address that can\n *   actually receive messages.\n *\n * @param {ProtectSignupOptions} options - The options for the signup form\n * protection rule.\n * @param {ArcjetMode} options.email.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block email addresses based on the\n * configuration, and `\"DRY_RUN\"` will allow all requests while still providing\n * access to the rule results. Defaults to `\"DRY_RUN\"` if not specified.\n * @param {Array<ArcjetEmailType>} options.email.deny - The list of email types\n * to deny. If provided, the email types in this list will be denied. You may\n * only provide either `allow` or `deny`, not both. Specify one or more of the\n * following:\n *\n * - `\"DISPOSABLE\"` - Disposable email addresses.\n * - `\"FREE\"` - Free email addresses.\n * - `\"NO_MX_RECORDS\"` - Email addresses with no MX records.\n * - `\"NO_GRAVATAR\"` - Email addresses with no Gravatar.\n * - `\"INVALID\"` - Invalid email addresses.\n *\n * @param {Array<ArcjetEmailType>} options.email.allow - The list of email types\n * to allow. If provided, email addresses in this list will be allowed and all\n * others will be denied. You may only provide either `allow` or `deny`, not\n * both. The same options apply as for `deny`.\n * @param {ArcjetMode} options.bots.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block detected bots, and `\"DRY_RUN\"`\n * will allow all requests while still providing access to the rule results.\n * Defaults to `\"DRY_RUN\"` if not specified.\n * @param {Array<ArcjetWellKnownBot | ArcjetBotCategory>} options.bots.allow -\n * The list of bots to allow. If provided, only the bots in this list will be\n * allowed and any other detected bot will be denied. If empty, all bots will be\n * denied. You may only provide either `allow` or `deny`, not both. You can use\n * specific bots e.g. `\"CURL\"` will allow the default user-agent of the `curl`\n * tool. You can also use categories e.g. `\"CATEGORY:SEARCH_ENGINE\"` will allow\n * all search engine bots. See\n * https://docs.arcjet.com/bot-protection/identifying-bots for the full list of\n * bots and categories.\n * @param {Array<ArcjetWellKnownBot | ArcjetBotCategory>} options.bots.deny -\n * The list of bots to deny. If provided, the bots in this list will be denied\n * and all other detected bots will be allowed. You may only provide either\n * `allow` or `deny`, not both. The same options apply as for `allow`.\n * @param {SlidingWindowRateLimitOptions} options.rateLimit - The options for\n * the sliding window rate limiting rule.\n * @param {ArcjetMode} options.rateLimit.mode - The block mode of the rule,\n * either `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block requests when the rate\n * limit is exceeded, and `\"DRY_RUN\"` will allow all requests while still\n * providing access to the rule results. Defaults to `\"DRY_RUN\"` if not\n * specified.\n * @param {string | number} options.rateLimit.interval - The time interval for\n * the rate limit. This can be a string like `\"60s\"` for 60 seconds, `\"1h45m\"`\n * for 1 hour and 45 minutes, or a number like `60` for 60 seconds. Valid string\n * time units are:\n * - `s` for seconds.\n * - `m` for minutes.\n * - `h` for hours.\n * - `d` for days.\n * @param {number} options.rateLimit.max - The maximum number of requests\n * allowed in the sliding time window.\n * @returns {Primitive} The signup form protection rule to provide to the SDK in\n * the `rules` option.\n *\n * @example\n * Our recommended configuration for most signup forms is:\n *\n * - Block emails with invalid syntax, that are from disposable email providers,\n *   or do not have valid MX records configured.\n * - Block all bots.\n * - Apply a rate limit of 5 submissions per 10 minutes from a single IP\n *   address.\n *\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *    protectSignup({\n *      email: {\n *        mode: \"LIVE\",\n *        block: [\"DISPOSABLE\", \"INVALID\", \"NO_MX_RECORDS\"],\n *      },\n *      bots: {\n *        mode: \"LIVE\",\n *        allow: [], // block all detected bots\n *      },\n *      rateLimit: {\n *        mode: \"LIVE\",\n *        interval: \"10m\",\n *        max: 5,\n *      },\n *    }),\n *  ],\n * });\n * ```\n * @link https://docs.arcjet.com/signup-protection/concepts\n * @link https://docs.arcjet.com/signup-protection/reference\n */\nfunction protectSignup(options) {\n    return [\n        ...slidingWindow(options.rateLimit),\n        ...detectBot(options.bots),\n        ...validateEmail(options.email),\n    ];\n}\n/**\n * Create a new Arcjet client with the specified {@link ArcjetOptions}.\n *\n * @param options {ArcjetOptions} Arcjet configuration options.\n */\nfunction arcjet(options) {\n    // We destructure here to make the function signature neat when viewed by consumers\n    const { key, rules } = options;\n    const rt = (0,_arcjet_runtime__WEBPACK_IMPORTED_MODULE_4__.runtime)();\n    // TODO: Separate the ArcjetOptions from the SDK Options\n    // It is currently optional in the options so users can override it via an SDK\n    if (typeof options.log === \"undefined\") {\n        throw new Error(\"Log is required\");\n    }\n    const log = options.log;\n    const perf = new Performance(log);\n    // TODO(#207): Remove this when we can default the transport so client is not required\n    // It is currently optional in the options so the Next SDK can override it for the user\n    if (typeof options.client === \"undefined\") {\n        throw new Error(\"Client is required\");\n    }\n    const client = options.client;\n    // A local cache of block decisions. Might be emphemeral per request,\n    // depending on the way the runtime works, but it's worth a try.\n    // TODO(#132): Support configurable caching\n    const cache = new _arcjet_cache__WEBPACK_IMPORTED_MODULE_6__.MemoryCache();\n    const rootRules = rules\n        .flat(1)\n        .sort((a, b) => a.priority - b.priority);\n    async function protect(rules, ctx, request) {\n        // This goes against the type definition above, but users might call\n        // `protect()` with no value and we don't want to crash\n        if (typeof request === \"undefined\") {\n            request = {};\n        }\n        const details = Object.freeze({\n            ip: request.ip,\n            method: request.method,\n            protocol: request.protocol,\n            host: request.host,\n            path: request.path,\n            headers: new _arcjet_headers__WEBPACK_IMPORTED_MODULE_3__[\"default\"](request.headers),\n            cookies: request.cookies,\n            query: request.query,\n            extra: extraProps(request),\n            email: typeof request.email === \"string\" ? request.email : undefined,\n        });\n        const characteristics = options.characteristics\n            ? [...options.characteristics]\n            : [];\n        const waitUntil = lookupWaitUntil();\n        const baseContext = {\n            key,\n            log,\n            characteristics,\n            waitUntil,\n            ...ctx,\n        };\n        let fingerprint = \"\";\n        const logFingerprintPerf = perf.measure(\"fingerprint\");\n        try {\n            fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(baseContext, toAnalyzeRequest(details));\n            log.debug(\"fingerprint (%s): %s\", rt, fingerprint);\n        }\n        catch (error) {\n            log.error({ error }, \"Failed to build fingerprint. Please verify your Characteristics.\");\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(`Failed to build fingerprint - ${errorMessage(error)}`),\n                // No results because we couldn't create a fingerprint\n                results: [],\n            });\n            // TODO: Consider sending this to Report when we have an infallible fingerprint\n            return decision;\n        }\n        finally {\n            logFingerprintPerf();\n        }\n        const context = Object.freeze({\n            ...baseContext,\n            cache,\n            fingerprint,\n            runtime: rt,\n        });\n        if (rules.length < 1) {\n            log.warn(\"Calling `protect()` with no rules is deprecated. Did you mean to configure the Shield rule?\");\n        }\n        if (rules.length > 10) {\n            log.error(\"Failure running rules. Only 10 rules may be specified.\");\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"Only 10 rules may be specified\"),\n                // No results because the sorted rules were too long and we don't want\n                // to instantiate a ton of NOT_RUN results\n                results: [],\n            });\n            client.report(context, details, decision, \n            // No rules because we've determined they were too long and we don't\n            // want to try to send them to the server\n            []);\n            return decision;\n        }\n        const results = [];\n        for (let idx = 0; idx < rules.length; idx++) {\n            // Default all rules to NOT_RUN/ALLOW before doing anything\n            results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                // TODO(#4030): Figure out if we can get each Rule ID before they are run\n                ruleId: \"\",\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetReason(),\n            });\n            // Add top-level characteristics to all Rate Limit rules that don't already have\n            // their own set of characteristics.\n            const candidate_rule = rules[idx];\n            if (isRateLimitRule(candidate_rule)) {\n                if (typeof candidate_rule.characteristics === \"undefined\") {\n                    candidate_rule.characteristics = characteristics;\n                    rules[idx] = candidate_rule;\n                }\n            }\n        }\n        const logLocalPerf = perf.measure(\"local\");\n        try {\n            for (const [idx, rule] of rules.entries()) {\n                // This re-assignment is a workaround to a TypeScript error with\n                // assertions where the name was introduced via a destructure\n                const localRule = rule;\n                const logRulePerf = perf.measure(rule.type);\n                try {\n                    if (typeof localRule.validate !== \"function\") {\n                        throw new Error(\"rule must have a `validate` function\");\n                    }\n                    localRule.validate(context, details);\n                    if (typeof localRule.protect !== \"function\") {\n                        throw new Error(\"rule must have a `protect` function\");\n                    }\n                    results[idx] = await localRule.protect(context, details);\n                    // If a rule didn't return a rule result, we need to stub it to avoid\n                    // crashing. This should only happen if a user writes a custom local\n                    // rule incorrectly.\n                    if (typeof results[idx] === \"undefined\") {\n                        results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                            // TODO(#4030): If we can get the Rule ID before running rules,\n                            // this can use it\n                            ruleId: \"\",\n                            fingerprint,\n                            ttl: 0,\n                            state: \"RUN\",\n                            conclusion: \"ERROR\",\n                            reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"rule result missing\"),\n                        });\n                    }\n                    log.debug({\n                        id: results[idx].ruleId,\n                        rule: rule.type,\n                        fingerprint,\n                        path: details.path,\n                        runtime: rt,\n                        ttl: results[idx].ttl,\n                        conclusion: results[idx].conclusion,\n                        reason: results[idx].reason,\n                    }, \"Local rule result:\");\n                }\n                catch (err) {\n                    log.error(\"Failure running rule: %s due to %s\", rule.type, errorMessage(err));\n                    results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                        // TODO(#4030): Figure out if we can get a Rule ID in this error case\n                        ruleId: \"\",\n                        fingerprint,\n                        ttl: 0,\n                        state: \"RUN\",\n                        conclusion: \"ERROR\",\n                        reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(err),\n                    });\n                }\n                finally {\n                    logRulePerf();\n                }\n                const result = results[idx];\n                if (result.isDenied()) {\n                    // If the rule is not a DRY_RUN, we want to cache non-zero TTL results\n                    // and return a DENY decision.\n                    if (result.state !== \"DRY_RUN\") {\n                        const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDenyDecision({\n                            ttl: result.ttl,\n                            reason: result.reason,\n                            results,\n                        });\n                        // Only a DENY decision is reported to avoid creating 2 entries for\n                        // a request. Upon ALLOW, the `decide` call will create an entry for\n                        // the request.\n                        client.report(context, details, decision, rules);\n                        if (result.ttl > 0) {\n                            log.debug({\n                                fingerprint: result.fingerprint,\n                                conclusion: result.conclusion,\n                                reason: result.reason,\n                            }, \"Caching decision for %d seconds\", decision.ttl);\n                            cache.set(result.ruleId, result.fingerprint, {\n                                conclusion: result.conclusion,\n                                reason: result.reason,\n                            }, result.ttl);\n                        }\n                        return decision;\n                    }\n                    log.warn(`Dry run mode is enabled for \"%s\" rule. Overriding decision. Decision was: DENY`, rule.type);\n                }\n            }\n        }\n        finally {\n            logLocalPerf();\n        }\n        // With no cached values, we take a decision remotely. We use a timeout to\n        // fail open.\n        const logRemotePerf = perf.measure(\"remote\");\n        try {\n            const logDediceApiPerf = perf.measure(\"decideApi\");\n            const decision = await client\n                .decide(context, details, rules)\n                .finally(() => {\n                logDediceApiPerf();\n            });\n            // If the decision is to block and we have a non-zero TTL, we cache the\n            // block locally\n            if (decision.isDenied() && decision.ttl > 0) {\n                log.debug(\"decide: Caching block locally for %d seconds\", decision.ttl);\n                for (const result of decision.results) {\n                    // Cache all DENY results for local cache lookups\n                    if (result.conclusion === \"DENY\") {\n                        cache.set(result.ruleId, result.fingerprint, {\n                            conclusion: result.conclusion,\n                            reason: result.reason,\n                        }, result.ttl);\n                    }\n                }\n            }\n            return decision;\n        }\n        catch (err) {\n            log.info(\"Encountered problem getting remote decision: %s\", errorMessage(err));\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(err),\n                results,\n            });\n            client.report(context, details, decision, rules);\n            return decision;\n        }\n        finally {\n            logRemotePerf();\n        }\n    }\n    // This is a separate function so it can be called recursively\n    function withRule(baseRules, rule) {\n        const rules = [...baseRules, ...rule].sort((a, b) => a.priority - b.priority);\n        return Object.freeze({\n            withRule(rule) {\n                return withRule(rules, rule);\n            },\n            async protect(ctx, request) {\n                return protect(rules, ctx, request);\n            },\n        });\n    }\n    return Object.freeze({\n        withRule(rule) {\n            return withRule(rootRules, rule);\n        },\n        async protect(ctx, request) {\n            return protect(rootRules, ctx, request);\n        },\n    });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXJjamV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3TztBQUN2TTtBQUNVO0FBQ0U7QUFDRDtBQUNGO0FBQ0k7QUFDRjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELElBQUksZ0JBQWdCLFNBQVM7QUFDbkY7QUFDQTtBQUNBLHNEQUFzRCxJQUFJLHVCQUF1QixpQkFBaUI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJLHVCQUF1QiwwQkFB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YjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpRUFBbUI7QUFDcEQ7QUFDQSw0QkFBNEIsK0RBQWlCO0FBQzdDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVzSSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEb3dubG9hZHNcXHF1aXp6LW1haW5cXHF1aXp6LW1haW5cXG5vZGVfbW9kdWxlc1xcYXJjamV0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcmNqZXRFcnJvckRlY2lzaW9uLCBBcmNqZXRFcnJvclJlYXNvbiwgQXJjamV0UnVsZVJlc3VsdCwgQXJjamV0UmVhc29uLCBBcmNqZXREZW55RGVjaXNpb24sIEFyY2pldEJvdFJlYXNvbiwgQXJjamV0UmF0ZUxpbWl0UmVhc29uLCBBcmNqZXRFbWFpbFJlYXNvbiwgQXJjamV0U2hpZWxkUmVhc29uLCBBcmNqZXRTZW5zaXRpdmVJbmZvUmVhc29uIH0gZnJvbSAnQGFyY2pldC9wcm90b2NvbCc7XG5leHBvcnQgKiBmcm9tICdAYXJjamV0L3Byb3RvY29sJztcbmltcG9ydCAqIGFzIGFuYWx5emUgZnJvbSAnQGFyY2pldC9hbmFseXplJztcbmltcG9ydCAqIGFzIGR1cmF0aW9uIGZyb20gJ0BhcmNqZXQvZHVyYXRpb24nO1xuaW1wb3J0IEFyY2pldEhlYWRlcnMgZnJvbSAnQGFyY2pldC9oZWFkZXJzJztcbmltcG9ydCB7IHJ1bnRpbWUgfSBmcm9tICdAYXJjamV0L3J1bnRpbWUnO1xuaW1wb3J0ICogYXMgaGFzaGVyIGZyb20gJ0BhcmNqZXQvc3RhYmxlLWhhc2gnO1xuaW1wb3J0IHsgTWVtb3J5Q2FjaGUgfSBmcm9tICdAYXJjamV0L2NhY2hlJztcblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXJyb3JNZXNzYWdlKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlcnIgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIFwibWVzc2FnZVwiIGluIGVyciAmJlxuICAgICAgICAgICAgdHlwZW9mIGVyci5tZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiVW5rbm93biBwcm9ibGVtXCI7XG59XG5jb25zdCBrbm93bkZpZWxkcyA9IFtcbiAgICBcImlwXCIsXG4gICAgXCJtZXRob2RcIixcbiAgICBcInByb3RvY29sXCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJwYXRoXCIsXG4gICAgXCJoZWFkZXJzXCIsXG4gICAgXCJib2R5XCIsXG4gICAgXCJlbWFpbFwiLFxuICAgIFwiY29va2llc1wiLFxuICAgIFwicXVlcnlcIixcbl07XG5mdW5jdGlvbiBpc1Vua25vd25SZXF1ZXN0UHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuICFrbm93bkZpZWxkcy5pbmNsdWRlcyhrZXkpO1xufVxuZnVuY3Rpb24gaXNFbWFpbFR5cGUodHlwZSkge1xuICAgIHJldHVybiAodHlwZSA9PT0gXCJGUkVFXCIgfHxcbiAgICAgICAgdHlwZSA9PT0gXCJESVNQT1NBQkxFXCIgfHxcbiAgICAgICAgdHlwZSA9PT0gXCJOT19NWF9SRUNPUkRTXCIgfHxcbiAgICAgICAgdHlwZSA9PT0gXCJOT19HUkFWQVRBUlwiIHx8XG4gICAgICAgIHR5cGUgPT09IFwiSU5WQUxJRFwiKTtcbn1cbmNsYXNzIFBlcmZvcm1hbmNlIHtcbiAgICBsb2c7XG4gICAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgICAgIHRoaXMubG9nID0gbG9nZ2VyO1xuICAgIH1cbiAgICAvLyBUT0RPKCMyMDIwKTogV2Ugc2hvdWxkIG5vLW9wIHRoaXMgaWYgbG9nbGV2ZWwgaXMgbm90IGBkZWJ1Z2AgdG8gZG8gbGVzcyB3b3JrXG4gICAgbWVhc3VyZShsYWJlbCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcIkxBVEVOQ1kgJXM6ICVzbXNcIiwgbGFiZWwsIGRpZmYudG9GaXhlZCgzKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gYCR7dmFsdWV9YDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gICAgfVxuICAgIHJldHVybiBcIjx1bnN1cHBvcnRlZCB2YWx1ZT5cIjtcbn1cbi8vIFRoaXMgaXMgdGhlIFN5bWJvbCB0aGF0IFZlcmNlbCBkZWZpbmVzIGluIHRoZWlyIGluZnJhc3RydWN0dXJlIHRvIGFjY2VzcyB0aGVcbi8vIENvbnRleHQgKHdoZXJlIGF2YWlsYWJsZSkuIFRoZSBDb250ZXh0IGNhbiBjb250YWluIHRoZSBgd2FpdFVudGlsYCBmdW5jdGlvbi5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvdmVyY2VsL2Jsb2IvOTMwZDdmYjg5MmRjMjZmMjQwZjJiOTUwZDk2MzkzMWM0NWUxZTY2MS9wYWNrYWdlcy9mdW5jdGlvbnMvc3JjL2dldC1jb250ZXh0LnRzI0w2XG5jb25zdCBTWU1CT0xfRk9SX1JFUV9DT05URVhUID0gU3ltYm9sLmZvcihcIkB2ZXJjZWwvcmVxdWVzdC1jb250ZXh0XCIpO1xuZnVuY3Rpb24gbG9va3VwV2FpdFVudGlsKCkge1xuICAgIGNvbnN0IGZyb21TeW1ib2wgPSBnbG9iYWxUaGlzO1xuICAgIGlmICh0eXBlb2YgZnJvbVN5bWJvbFtTWU1CT0xfRk9SX1JFUV9DT05URVhUXSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBmcm9tU3ltYm9sW1NZTUJPTF9GT1JfUkVRX0NPTlRFWFRdICE9PSBudWxsICYmXG4gICAgICAgIFwiZ2V0XCIgaW4gZnJvbVN5bWJvbFtTWU1CT0xfRk9SX1JFUV9DT05URVhUXSAmJlxuICAgICAgICB0eXBlb2YgZnJvbVN5bWJvbFtTWU1CT0xfRk9SX1JFUV9DT05URVhUXS5nZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCB2ZXJjZWxDdHggPSBmcm9tU3ltYm9sW1NZTUJPTF9GT1JfUkVRX0NPTlRFWFRdLmdldCgpO1xuICAgICAgICBpZiAodHlwZW9mIHZlcmNlbEN0eCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgdmVyY2VsQ3R4ICE9PSBudWxsICYmXG4gICAgICAgICAgICBcIndhaXRVbnRpbFwiIGluIHZlcmNlbEN0eCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZlcmNlbEN0eC53YWl0VW50aWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHZlcmNlbEN0eC53YWl0VW50aWw7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0b0FuYWx5emVSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LmhlYWRlcnMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcmVxdWVzdC5oZWFkZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgaGVhZGVycyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZXh0cmFQcm9wcyhkZXRhaWxzKSB7XG4gICAgY29uc3QgZXh0cmEgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGV0YWlscykpIHtcbiAgICAgICAgaWYgKGlzVW5rbm93blJlcXVlc3RQcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBleHRyYS5zZXQoa2V5LCB0b1N0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZXh0cmEuZW50cmllcygpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVWYWxpZGF0b3IoLi4udHlwZXMpIHtcbiAgICByZXR1cm4gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdHlwZU9mVmFsdWUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIGlmICghdHlwZXMuaW5jbHVkZXModHlwZU9mVmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHR5cGUgZm9yIFxcYCR7a2V5fVxcYCAtIGV4cGVjdGVkICR7dHlwZXNbMF19YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdHlwZSBmb3IgXFxgJHtrZXl9XFxgIC0gZXhwZWN0ZWQgb25lIG9mICR7dHlwZXMuam9pbihcIiwgXCIpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbHVlVmFsaWRhdG9yKFxuLy8gVGhpcyB1c2VzIHR5cGVzIHRvIGVuc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IDIgdmFsdWVzXG4uLi52YWx1ZXMpIHtcbiAgICByZXR1cm4gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgLy8gV2UgY2FzdCB0aGUgdmFsdWVzIHRvIHVua25vd24gYmVjYXVzZSB0aGUgb3B0aW9uVmFsdWUgaXNuJ3Qga25vd24gYnV0XG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byB1c2UgYHZhbHVlc2Agb24gc3RyaW5nIGVudW1lcmF0aW9uc1xuICAgICAgICBpZiAoIXZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB2YWx1ZSBmb3IgXFxgJHtrZXl9XFxgIC0gZXhwZWN0ZWQgb25lIG9mICR7dmFsdWVzLm1hcCgodmFsdWUpID0+IGAnJHt2YWx1ZX0nYCkuam9pbihcIiwgXCIpfWApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5VmFsaWRhdG9yKHZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaWR4LCBpdGVtXSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZShgJHtrZXl9WyR7aWR4fV1gLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlIGZvciBcXGAke2tleX1cXGAgLSBleHBlY3RlZCBhbiBhcnJheWApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRvcih7IHJ1bGUsIHZhbGlkYXRpb25zLCB9KSB7XG4gICAgcmV0dXJuIChvcHRpb25zKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgeyBrZXksIHZhbGlkYXRlLCByZXF1aXJlZCB9IG9mIHZhbGlkYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAocmVxdWlyZWQgJiYgIU9iamVjdC5oYXNPd24ob3B0aW9ucywga2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgJHtydWxlfVxcYCBvcHRpb25zIGVycm9yOiBcXGAke2tleX1cXGAgaXMgcmVxdWlyZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgLy8gVGhlIGByZXF1aXJlZGAgZmxhZyBpcyBjaGVja2VkIGFib3ZlLCBzbyB0aGVzZSBzaG91bGQgb25seSBiZSB2YWxpZGF0ZWRcbiAgICAgICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgJHtydWxlfVxcYCBvcHRpb25zIGVycm9yOiAke2Vycm9yTWVzc2FnZShlcnIpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCB2YWxpZGF0ZVN0cmluZyA9IGNyZWF0ZVR5cGVWYWxpZGF0b3IoXCJzdHJpbmdcIik7XG5jb25zdCB2YWxpZGF0ZU51bWJlciA9IGNyZWF0ZVR5cGVWYWxpZGF0b3IoXCJudW1iZXJcIik7XG5jb25zdCB2YWxpZGF0ZUJvb2xlYW4gPSBjcmVhdGVUeXBlVmFsaWRhdG9yKFwiYm9vbGVhblwiKTtcbmNvbnN0IHZhbGlkYXRlRnVuY3Rpb24gPSBjcmVhdGVUeXBlVmFsaWRhdG9yKFwiZnVuY3Rpb25cIik7XG5jb25zdCB2YWxpZGF0ZVN0cmluZ09yTnVtYmVyID0gY3JlYXRlVHlwZVZhbGlkYXRvcihcInN0cmluZ1wiLCBcIm51bWJlclwiKTtcbmNvbnN0IHZhbGlkYXRlU3RyaW5nQXJyYXkgPSBjcmVhdGVBcnJheVZhbGlkYXRvcih2YWxpZGF0ZVN0cmluZyk7XG5jb25zdCB2YWxpZGF0ZU1vZGUgPSBjcmVhdGVWYWx1ZVZhbGlkYXRvcihcIkxJVkVcIiwgXCJEUllfUlVOXCIpO1xuY29uc3QgdmFsaWRhdGVFbWFpbFR5cGVzID0gY3JlYXRlQXJyYXlWYWxpZGF0b3IoY3JlYXRlVmFsdWVWYWxpZGF0b3IoXCJESVNQT1NBQkxFXCIsIFwiRlJFRVwiLCBcIk5PX01YX1JFQ09SRFNcIiwgXCJOT19HUkFWQVRBUlwiLCBcIklOVkFMSURcIikpO1xuY29uc3QgdmFsaWRhdGVUb2tlbkJ1Y2tldE9wdGlvbnMgPSBjcmVhdGVWYWxpZGF0b3Ioe1xuICAgIHJ1bGU6IFwidG9rZW5CdWNrZXRcIixcbiAgICB2YWxpZGF0aW9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibW9kZVwiLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlTW9kZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNoYXJhY3RlcmlzdGljc1wiLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXksXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHsga2V5OiBcInJlZmlsbFJhdGVcIiwgcmVxdWlyZWQ6IHRydWUsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgICAgICB7IGtleTogXCJpbnRlcnZhbFwiLCByZXF1aXJlZDogdHJ1ZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nT3JOdW1iZXIgfSxcbiAgICAgICAgeyBrZXk6IFwiY2FwYWNpdHlcIiwgcmVxdWlyZWQ6IHRydWUsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgIF0sXG59KTtcbmNvbnN0IHZhbGlkYXRlRml4ZWRXaW5kb3dPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcImZpeGVkV2luZG93XCIsXG4gICAgdmFsaWRhdGlvbnM6IFtcbiAgICAgICAgeyBrZXk6IFwibW9kZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU1vZGUgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNoYXJhY3RlcmlzdGljc1wiLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXksXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHsga2V5OiBcIm1heFwiLCByZXF1aXJlZDogdHJ1ZSwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgICAgIHsga2V5OiBcIndpbmRvd1wiLCByZXF1aXJlZDogdHJ1ZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nT3JOdW1iZXIgfSxcbiAgICBdLFxufSk7XG5jb25zdCB2YWxpZGF0ZVNsaWRpbmdXaW5kb3dPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcInNsaWRpbmdXaW5kb3dcIixcbiAgICB2YWxpZGF0aW9uczogW1xuICAgICAgICB7IGtleTogXCJtb2RlXCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlTW9kZSB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2hhcmFjdGVyaXN0aWNzXCIsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdBcnJheSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBrZXk6IFwibWF4XCIsIHJlcXVpcmVkOiB0cnVlLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAgICAgeyBrZXk6IFwiaW50ZXJ2YWxcIiwgcmVxdWlyZWQ6IHRydWUsIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ09yTnVtYmVyIH0sXG4gICAgXSxcbn0pO1xuY29uc3QgdmFsaWRhdGVTZW5zaXRpdmVJbmZvT3B0aW9ucyA9IGNyZWF0ZVZhbGlkYXRvcih7XG4gICAgcnVsZTogXCJzZW5zaXRpdmVJbmZvXCIsXG4gICAgdmFsaWRhdGlvbnM6IFtcbiAgICAgICAgeyBrZXk6IFwibW9kZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU1vZGUgfSxcbiAgICAgICAgeyBrZXk6IFwiYWxsb3dcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdBcnJheSB9LFxuICAgICAgICB7IGtleTogXCJkZW55XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXkgfSxcbiAgICAgICAgeyBrZXk6IFwiY29udGV4dFdpbmRvd1NpemVcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAgICAgeyBrZXk6IFwiZGV0ZWN0XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlRnVuY3Rpb24gfSxcbiAgICBdLFxufSk7XG5jb25zdCB2YWxpZGF0ZUVtYWlsT3B0aW9ucyA9IGNyZWF0ZVZhbGlkYXRvcih7XG4gICAgcnVsZTogXCJ2YWxpZGF0ZUVtYWlsXCIsXG4gICAgdmFsaWRhdGlvbnM6IFtcbiAgICAgICAgeyBrZXk6IFwibW9kZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU1vZGUgfSxcbiAgICAgICAgeyBrZXk6IFwiYmxvY2tcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVFbWFpbFR5cGVzIH0sXG4gICAgICAgIHsga2V5OiBcImFsbG93XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlRW1haWxUeXBlcyB9LFxuICAgICAgICB7IGtleTogXCJkZW55XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlRW1haWxUeXBlcyB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicmVxdWlyZVRvcExldmVsRG9tYWluXCIsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGVCb29sZWFuLFxuICAgICAgICB9LFxuICAgICAgICB7IGtleTogXCJhbGxvd0RvbWFpbkxpdGVyYWxcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVCb29sZWFuIH0sXG4gICAgXSxcbn0pO1xuY29uc3QgdmFsaWRhdGVCb3RPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcImRldGVjdEJvdFwiLFxuICAgIHZhbGlkYXRpb25zOiBbXG4gICAgICAgIHsga2V5OiBcIm1vZGVcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVNb2RlIH0sXG4gICAgICAgIHsga2V5OiBcImFsbG93XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXkgfSxcbiAgICAgICAgeyBrZXk6IFwiZGVueVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ0FycmF5IH0sXG4gICAgXSxcbn0pO1xuY29uc3QgdmFsaWRhdGVTaGllbGRPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcInNoaWVsZFwiLFxuICAgIHZhbGlkYXRpb25zOiBbeyBrZXk6IFwibW9kZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU1vZGUgfV0sXG59KTtcbmNvbnN0IFByaW9yaXR5ID0ge1xuICAgIFNlbnNpdGl2ZUluZm86IDEsXG4gICAgU2hpZWxkOiAyLFxuICAgIFJhdGVMaW1pdDogMyxcbiAgICBCb3REZXRlY3Rpb246IDQsXG4gICAgRW1haWxWYWxpZGF0aW9uOiA1LFxufTtcbmZ1bmN0aW9uIGlzUmF0ZUxpbWl0UnVsZShydWxlKSB7XG4gICAgcmV0dXJuIHJ1bGUudHlwZSA9PT0gXCJSQVRFX0xJTUlUXCI7XG59XG4vKipcbiAqIEFyY2pldCB0b2tlbiBidWNrZXQgcmF0ZSBsaW1pdGluZyBydWxlLiBBcHBseWluZyB0aGlzIHJ1bGUgc2V0cyBhIHRva2VuXG4gKiBidWNrZXQgcmF0ZSBsaW1pdC5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBpcyBiYXNlZCBvbiBhIGJ1Y2tldCBmaWxsZWQgd2l0aCBhIHNwZWNpZmljIG51bWJlciBvZiB0b2tlbnMuXG4gKiBFYWNoIHJlcXVlc3Qgd2l0aGRyYXdzIHNvbWUgYW1vdW50IG9mIHRva2VucyBmcm9tIHRoZSBidWNrZXQgYW5kIHRoZSBidWNrZXRcbiAqIGlzIHJlZmlsbGVkIGF0IGEgZml4ZWQgcmF0ZS4gT25jZSB0aGUgYnVja2V0IGlzIGVtcHR5LCB0aGUgY2xpZW50IGlzIGJsb2NrZWRcbiAqIHVudGlsIHRoZSBidWNrZXQgcmVmaWxscy5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBhbGxvdyBjbGllbnRzIHRvIG1ha2UgYSBidXJzdCBvZlxuICogcmVxdWVzdHMgYW5kIHRoZW4gc3RpbGwgYmUgYWJsZSB0byBtYWtlIHJlcXVlc3RzIGF0IGEgc2xvd2VyIHJhdGUuXG4gKlxuICogQHBhcmFtIHtUb2tlbkJ1Y2tldFJhdGVMaW1pdE9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHRva2VuXG4gKiBidWNrZXQgcmF0ZSBsaW1pdGluZyBydWxlLlxuICogQHBhcmFtIHtBcmNqZXRNb2RlfSBvcHRpb25zLm1vZGUgLSBUaGUgYmxvY2sgbW9kZSBvZiB0aGUgcnVsZSwgZWl0aGVyXG4gKiBgXCJMSVZFXCJgIG9yIGBcIkRSWV9SVU5cImAuIGBcIkxJVkVcImAgd2lsbCBibG9jayByZXF1ZXN0cyB3aGVuIHRoZSByYXRlIGxpbWl0IGlzXG4gKiBleGNlZWRlZCwgYW5kIGBcIkRSWV9SVU5cImAgd2lsbCBhbGxvdyBhbGwgcmVxdWVzdHMgd2hpbGUgc3RpbGwgcHJvdmlkaW5nXG4gKiBhY2Nlc3MgdG8gdGhlIHJ1bGUgcmVzdWx0cy4gRGVmYXVsdHMgdG8gYFwiRFJZX1JVTlwiYCBpZiBub3Qgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucmVmaWxsUmF0ZSAtIFRoZSBudW1iZXIgb2YgdG9rZW5zIHRvIGFkZCB0byB0aGVcbiAqIGJ1Y2tldCBhdCBlYWNoIGludGVydmFsLiBGb3IgZXhhbXBsZSwgaWYgeW91IHNldCB0aGUgaW50ZXJ2YWwgdG8gNjAgYW5kIHRoZVxuICogcmVmaWxsIHJhdGUgdG8gMTAsIHRoZSBidWNrZXQgd2lsbCByZWZpbGwgMTAgdG9rZW5zIGV2ZXJ5IDYwIHNlY29uZHMuXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gb3B0aW9ucy5pbnRlcnZhbCAtIFRoZSB0aW1lIGludGVydmFsIGZvciB0aGUgcmVmaWxsXG4gKiByYXRlLiBUaGlzIGNhbiBiZSBhIHN0cmluZyBsaWtlIGBcIjYwc1wiYCBmb3IgNjAgc2Vjb25kcywgYFwiMWg0NW1cImAgZm9yIDEgaG91clxuICogYW5kIDQ1IG1pbnV0ZXMsIG9yIGEgbnVtYmVyIGxpa2UgYDYwYCBmb3IgNjAgc2Vjb25kcy4gVmFsaWQgc3RyaW5nIHRpbWUgdW5pdHNcbiAqIGFyZTpcbiAqIC0gYHNgIGZvciBzZWNvbmRzLlxuICogLSBgbWAgZm9yIG1pbnV0ZXMuXG4gKiAtIGBoYCBmb3IgaG91cnMuXG4gKiAtIGBkYCBmb3IgZGF5cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNhcGFjaXR5IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRva2VucyB0aGUgYnVja2V0XG4gKiBjYW4gaG9sZC4gVGhlIGJ1Y2tldCBzdGFydHMgYXQgZnVsbCBjYXBhY2l0eSBhbmQgd2lsbCByZWZpbGwgdW50aWwgaXQgaGl0c1xuICogdGhlIGNhcGFjaXR5LlxuICogQHJldHVybnMge1ByaW1pdGl2ZX0gVGhlIHRva2VuIGJ1Y2tldCBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpbiB0aGVcbiAqIGBydWxlc2Agb3B0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogdG9rZW5CdWNrZXQoeyBtb2RlOiBcIkxJVkVcIiwgcmVmaWxsUmF0ZTogMTAsIGludGVydmFsOiBcIjYwc1wiLCBjYXBhY2l0eTogMTAwIH0pO1xuICogYGBgXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICBydWxlczogW1xuICogICAgIHRva2VuQnVja2V0KHtcbiAqICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgcmVmaWxsUmF0ZTogMTAsXG4gKiAgICAgICBpbnRlcnZhbDogXCI2MHNcIixcbiAqICAgICAgIGNhcGFjaXR5OiAxMDAsXG4gKiAgICAgfSlcbiAqICAgXSxcbiAqIH0pO1xuICogYGBgXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL2FsZ29yaXRobXMjdG9rZW4tYnVja2V0XG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL3JlZmVyZW5jZVxuICovXG5mdW5jdGlvbiB0b2tlbkJ1Y2tldChvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVUb2tlbkJ1Y2tldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgdHlwZSA9IFwiUkFURV9MSU1JVFwiO1xuICAgIGNvbnN0IHZlcnNpb24gPSAwO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzKVxuICAgICAgICA/IG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlZmlsbFJhdGUgPSBvcHRpb25zLnJlZmlsbFJhdGU7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBkdXJhdGlvbi5wYXJzZShvcHRpb25zLmludGVydmFsKTtcbiAgICBjb25zdCBjYXBhY2l0eSA9IG9wdGlvbnMuY2FwYWNpdHk7XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5LlJhdGVMaW1pdCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICBhbGdvcml0aG06IFwiVE9LRU5fQlVDS0VUXCIsXG4gICAgICAgIHJlZmlsbFJhdGUsXG4gICAgICAgIGludGVydmFsLFxuICAgICAgICBjYXBhY2l0eSxcbiAgICAgICAgdmFsaWRhdGUoKSB7IH0sXG4gICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgZGV0YWlscykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxDaGFyYWN0ZXJpc3RpY3MgPSBjaGFyYWN0ZXJpc3RpY3MgPz8gY29udGV4dC5jaGFyYWN0ZXJpc3RpY3M7XG4gICAgICAgICAgICBjb25zdCBydWxlSWQgPSBhd2FpdCBoYXNoZXIuaGFzaChoYXNoZXIuc3RyaW5nKFwidHlwZVwiLCB0eXBlKSwgaGFzaGVyLnVpbnQzMihcInZlcnNpb25cIiwgdmVyc2lvbiksIGhhc2hlci5zdHJpbmcoXCJtb2RlXCIsIG1vZGUpLCBoYXNoZXIuc3RyaW5nKFwiYWxnb3JpdGhtXCIsIFwiVE9LRU5fQlVDS0VUXCIpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiY2hhcmFjdGVyaXN0aWNzXCIsIGxvY2FsQ2hhcmFjdGVyaXN0aWNzKSwgXG4gICAgICAgICAgICAvLyBNYXRjaCBpcyBkZXByZWNhdGVkIHNvIGl0IGlzIGFsd2F5cyBhbiBlbXB0eSBzdHJpbmcgaW4gdGhlIG5ld2VzdCBTREtzXG4gICAgICAgICAgICBoYXNoZXIuc3RyaW5nKFwibWF0Y2hcIiwgXCJcIiksIGhhc2hlci51aW50MzIoXCJyZWZpbGxSYXRlXCIsIHJlZmlsbFJhdGUpLCBoYXNoZXIudWludDMyKFwiaW50ZXJ2YWxcIiwgaW50ZXJ2YWwpLCBoYXNoZXIudWludDMyKFwiY2FwYWNpdHlcIiwgY2FwYWNpdHkpKTtcbiAgICAgICAgICAgIGNvbnN0IGFuYWx5emVDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogbG9jYWxDaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgICAgICAgICAgbG9nOiBjb250ZXh0LmxvZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmaW5nZXJwcmludCA9IGF3YWl0IGFuYWx5emUuZ2VuZXJhdGVGaW5nZXJwcmludChhbmFseXplQ29udGV4dCwgdG9BbmFseXplUmVxdWVzdChkZXRhaWxzKSk7XG4gICAgICAgICAgICBjb25zdCBbY2FjaGVkLCB0dGxdID0gYXdhaXQgY29udGV4dC5jYWNoZS5nZXQocnVsZUlkLCBmaW5nZXJwcmludCk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5yZWFzb24uaXNSYXRlTGltaXQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHR0bCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiQ0FDSEVEXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IGNhY2hlZC5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSByZWJ1aWxkIHRoZSBgQXJjamV0UmF0ZUxpbWl0UmVhc29uYCBiZWNhdXNlIHdlIG5lZWQgdG8gYWRqdXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgcmVzZXRgIGJhc2VkIG9uIHRoZSBjdXJyZW50IHRpbWUtdG8tbGl2ZVxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRSYXRlTGltaXRSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBjYWNoZWQucmVhc29uLm1heCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZzogY2FjaGVkLnJlYXNvbi5yZW1haW5pbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldDogdHRsLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93OiBjYWNoZWQucmVhc29uLndpbmRvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0VGltZTogY2FjaGVkLnJlYXNvbi5yZXNldFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBcIk5PVF9SVU5cIixcbiAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkFMTE9XXCIsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0UmF0ZUxpbWl0UmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4OiAwLFxuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0VGltZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIFtydWxlXTtcbn1cbi8qKlxuICogQXJjamV0IGZpeGVkIHdpbmRvdyByYXRlIGxpbWl0aW5nIHJ1bGUuIEFwcGx5aW5nIHRoaXMgcnVsZSBzZXRzIGEgZml4ZWRcbiAqIHdpbmRvdyByYXRlIGxpbWl0IHdoaWNoIHRyYWNrcyB0aGUgbnVtYmVyIG9mIHJlcXVlc3RzIG1hZGUgYnkgYSBjbGllbnQgb3ZlciBhXG4gKiBmaXhlZCB0aW1lIHdpbmRvdy5cbiAqXG4gKiBUaGlzIGlzIHRoZSBzaW1wbGVzdCBhbGdvcml0aG0uIEl0IHRyYWNrcyB0aGUgbnVtYmVyIG9mIHJlcXVlc3RzIG1hZGUgYnkgYVxuICogY2xpZW50IG92ZXIgYSBmaXhlZCB0aW1lIHdpbmRvdyBlLmcuIDYwIHNlY29uZHMuIElmIHRoZSBjbGllbnQgZXhjZWVkcyB0aGVcbiAqIGxpbWl0LCB0aGV5IGFyZSBibG9ja2VkIHVudGlsIHRoZSB3aW5kb3cgZXhwaXJlcy5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBhcHBseSBhIHNpbXBsZSBmaXhlZCBsaW1pdCBpbiBhXG4gKiBmaXhlZCB0aW1lIHdpbmRvdy4gRm9yIGV4YW1wbGUsIGEgc2ltcGxlIGxpbWl0IG9uIHRoZSB0b3RhbCBudW1iZXIgb2ZcbiAqIHJlcXVlc3RzIGEgY2xpZW50IGNhbiBtYWtlLiBIb3dldmVyLCBpdCBjYW4gYmUgc3VzY2VwdGlibGUgdG8gdGhlIHN0YW1wZWRlXG4gKiBwcm9ibGVtIHdoZXJlIGEgY2xpZW50IG1ha2VzIGEgYnVyc3Qgb2YgcmVxdWVzdHMgYXQgdGhlIHN0YXJ0IG9mIGEgd2luZG93IGFuZFxuICogdGhlbiBpcyBibG9ja2VkIGZvciB0aGUgcmVzdCBvZiB0aGUgd2luZG93LiBUaGUgc2xpZGluZyB3aW5kb3cgYWxnb3JpdGhtIGNhblxuICogYmUgdXNlZCB0byBhdm9pZCB0aGlzLlxuICpcbiAqIEBwYXJhbSB7Rml4ZWRXaW5kb3dSYXRlTGltaXRPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBmaXhlZFxuICogd2luZG93IHJhdGUgbGltaXRpbmcgcnVsZS5cbiAqIEBwYXJhbSB7QXJjamV0TW9kZX0gb3B0aW9ucy5tb2RlIC0gVGhlIGJsb2NrIG1vZGUgb2YgdGhlIHJ1bGUsIGVpdGhlclxuICogYFwiTElWRVwiYCBvciBgXCJEUllfUlVOXCJgLiBgXCJMSVZFXCJgIHdpbGwgYmxvY2sgcmVxdWVzdHMgd2hlbiB0aGUgcmF0ZSBsaW1pdCBpc1xuICogZXhjZWVkZWQsIGFuZCBgXCJEUllfUlVOXCJgIHdpbGwgYWxsb3cgYWxsIHJlcXVlc3RzIHdoaWxlIHN0aWxsIHByb3ZpZGluZ1xuICogYWNjZXNzIHRvIHRoZSBydWxlIHJlc3VsdHMuIERlZmF1bHRzIHRvIGBcIkRSWV9SVU5cImAgaWYgbm90IHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBvcHRpb25zLndpbmRvdyAtIFRoZSBmaXhlZCB0aW1lIHdpbmRvdy4gVGhpcyBjYW4gYmVcbiAqIGEgc3RyaW5nIGxpa2UgYFwiNjBzXCJgIGZvciA2MCBzZWNvbmRzLCBgXCIxaDQ1bVwiYCBmb3IgMSBob3VyIGFuZCA0NSBtaW51dGVzLCBvclxuICogYSBudW1iZXIgbGlrZSBgNjBgIGZvciA2MCBzZWNvbmRzLiBWYWxpZCBzdHJpbmcgdGltZSB1bml0cyBhcmU6XG4gKiAtIGBzYCBmb3Igc2Vjb25kcy5cbiAqIC0gYG1gIGZvciBtaW51dGVzLlxuICogLSBgaGAgZm9yIGhvdXJzLlxuICogLSBgZGAgZm9yIGRheXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tYXggLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVxdWVzdHMgYWxsb3dlZCBpbiB0aGVcbiAqIGZpeGVkIHRpbWUgd2luZG93LlxuICogQHJldHVybnMge1ByaW1pdGl2ZX0gVGhlIGZpeGVkIHdpbmRvdyBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpbiB0aGVcbiAqIGBydWxlc2Agb3B0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogZml4ZWRXaW5kb3coeyBtb2RlOiBcIkxJVkVcIiwgd2luZG93OiBcIjYwc1wiLCBtYXg6IDEwMCB9KTtcbiAqIGBgYFxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgICBrZXk6IHByb2Nlc3MuZW52LkFSQ0pFVF9LRVksXG4gKiAgIHJ1bGVzOiBbXG4gKiAgICAgZml4ZWRXaW5kb3coe1xuICogICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICB3aW5kb3c6IFwiNjBzXCIsXG4gKiAgICAgICBtYXg6IDEwMCxcbiAqICAgICB9KVxuICogICBdLFxuICogfSk7XG4gKiBgYGBcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3JhdGUtbGltaXRpbmcvY29uY2VwdHNcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3JhdGUtbGltaXRpbmcvYWxnb3JpdGhtcyNmaXhlZC13aW5kb3dcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3JhdGUtbGltaXRpbmcvcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIGZpeGVkV2luZG93KG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZUZpeGVkV2luZG93T3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB0eXBlID0gXCJSQVRFX0xJTUlUXCI7XG4gICAgY29uc3QgdmVyc2lvbiA9IDA7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gXCJMSVZFXCIgPyBcIkxJVkVcIiA6IFwiRFJZX1JVTlwiO1xuICAgIGNvbnN0IGNoYXJhY3RlcmlzdGljcyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5jaGFyYWN0ZXJpc3RpY3MpXG4gICAgICAgID8gb3B0aW9ucy5jaGFyYWN0ZXJpc3RpY3NcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbWF4ID0gb3B0aW9ucy5tYXg7XG4gICAgY29uc3Qgd2luZG93ID0gZHVyYXRpb24ucGFyc2Uob3B0aW9ucy53aW5kb3cpO1xuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5SYXRlTGltaXQsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGNoYXJhY3RlcmlzdGljcyxcbiAgICAgICAgYWxnb3JpdGhtOiBcIkZJWEVEX1dJTkRPV1wiLFxuICAgICAgICBtYXgsXG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgdmFsaWRhdGUoKSB7IH0sXG4gICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgZGV0YWlscykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxDaGFyYWN0ZXJpc3RpY3MgPSBjaGFyYWN0ZXJpc3RpY3MgPz8gY29udGV4dC5jaGFyYWN0ZXJpc3RpY3M7XG4gICAgICAgICAgICBjb25zdCBydWxlSWQgPSBhd2FpdCBoYXNoZXIuaGFzaChoYXNoZXIuc3RyaW5nKFwidHlwZVwiLCB0eXBlKSwgaGFzaGVyLnVpbnQzMihcInZlcnNpb25cIiwgdmVyc2lvbiksIGhhc2hlci5zdHJpbmcoXCJtb2RlXCIsIG1vZGUpLCBoYXNoZXIuc3RyaW5nKFwiYWxnb3JpdGhtXCIsIFwiRklYRURfV0lORE9XXCIpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiY2hhcmFjdGVyaXN0aWNzXCIsIGxvY2FsQ2hhcmFjdGVyaXN0aWNzKSwgXG4gICAgICAgICAgICAvLyBNYXRjaCBpcyBkZXByZWNhdGVkIHNvIGl0IGlzIGFsd2F5cyBhbiBlbXB0eSBzdHJpbmcgaW4gdGhlIG5ld2VzdCBTREtzXG4gICAgICAgICAgICBoYXNoZXIuc3RyaW5nKFwibWF0Y2hcIiwgXCJcIiksIGhhc2hlci51aW50MzIoXCJtYXhcIiwgbWF4KSwgaGFzaGVyLnVpbnQzMihcIndpbmRvd1wiLCB3aW5kb3cpKTtcbiAgICAgICAgICAgIGNvbnN0IGFuYWx5emVDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogbG9jYWxDaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgICAgICAgICAgbG9nOiBjb250ZXh0LmxvZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmaW5nZXJwcmludCA9IGF3YWl0IGFuYWx5emUuZ2VuZXJhdGVGaW5nZXJwcmludChhbmFseXplQ29udGV4dCwgdG9BbmFseXplUmVxdWVzdChkZXRhaWxzKSk7XG4gICAgICAgICAgICBjb25zdCBbY2FjaGVkLCB0dGxdID0gYXdhaXQgY29udGV4dC5jYWNoZS5nZXQocnVsZUlkLCBmaW5nZXJwcmludCk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5yZWFzb24uaXNSYXRlTGltaXQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHR0bCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiQ0FDSEVEXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IGNhY2hlZC5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSByZWJ1aWxkIHRoZSBgQXJjamV0UmF0ZUxpbWl0UmVhc29uYCBiZWNhdXNlIHdlIG5lZWQgdG8gYWRqdXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgcmVzZXRgIGJhc2VkIG9uIHRoZSBjdXJyZW50IHRpbWUtdG8tbGl2ZVxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRSYXRlTGltaXRSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBjYWNoZWQucmVhc29uLm1heCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZzogY2FjaGVkLnJlYXNvbi5yZW1haW5pbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldDogdHRsLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93OiBjYWNoZWQucmVhc29uLndpbmRvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0VGltZTogY2FjaGVkLnJlYXNvbi5yZXNldFRpbWUsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBcIk5PVF9SVU5cIixcbiAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkFMTE9XXCIsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0UmF0ZUxpbWl0UmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4OiAwLFxuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IDAsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBbcnVsZV07XG59XG4vKipcbiAqIEFyY2pldCBzbGlkaW5nIHdpbmRvdyByYXRlIGxpbWl0aW5nIHJ1bGUuIEFwcGx5aW5nIHRoaXMgcnVsZSBzZXRzIGEgc2xpZGluZ1xuICogd2luZG93IHJhdGUgbGltaXQgd2hpY2ggdHJhY2tzIHRoZSBudW1iZXIgb2YgcmVxdWVzdHMgbWFkZSBieSBhIGNsaWVudCBvdmVyIGFcbiAqIHNsaWRpbmcgd2luZG93IHNvIHRoYXQgdGhlIHdpbmRvdyBtb3ZlcyB3aXRoIHRpbWUuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gaXMgdXNlZnVsIHRvIGF2b2lkIHRoZSBzdGFtcGVkZSBwcm9ibGVtIG9mIHRoZSBmaXhlZCB3aW5kb3cuXG4gKiBJdCBwcm92aWRlcyBzbW9vdGhlciByYXRlIGxpbWl0aW5nIG92ZXIgdGltZSBhbmQgY2FuIHByZXZlbnQgYSBjbGllbnQgZnJvbVxuICogbWFraW5nIGEgYnVyc3Qgb2YgcmVxdWVzdHMgYXQgdGhlIHN0YXJ0IG9mIGEgd2luZG93IGFuZCB0aGVuIGJlaW5nIGJsb2NrZWRcbiAqIGZvciB0aGUgcmVzdCBvZiB0aGUgd2luZG93LlxuICpcbiAqIEBwYXJhbSB7U2xpZGluZ1dpbmRvd1JhdGVMaW1pdE9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHNsaWRpbmdcbiAqIHdpbmRvdyByYXRlIGxpbWl0aW5nIHJ1bGUuXG4gKiBAcGFyYW0ge0FyY2pldE1vZGV9IG9wdGlvbnMubW9kZSAtIFRoZSBibG9jayBtb2RlIG9mIHRoZSBydWxlLCBlaXRoZXJcbiAqIGBcIkxJVkVcImAgb3IgYFwiRFJZX1JVTlwiYC4gYFwiTElWRVwiYCB3aWxsIGJsb2NrIHJlcXVlc3RzIHdoZW4gdGhlIHJhdGUgbGltaXQgaXNcbiAqIGV4Y2VlZGVkLCBhbmQgYFwiRFJZX1JVTlwiYCB3aWxsIGFsbG93IGFsbCByZXF1ZXN0cyB3aGlsZSBzdGlsbCBwcm92aWRpbmdcbiAqIGFjY2VzcyB0byB0aGUgcnVsZSByZXN1bHRzLiBEZWZhdWx0cyB0byBgXCJEUllfUlVOXCJgIGlmIG5vdCBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gb3B0aW9ucy5pbnRlcnZhbCAtIFRoZSB0aW1lIGludGVydmFsIGZvciB0aGUgcmF0ZVxuICogbGltaXQuIFRoaXMgY2FuIGJlIGEgc3RyaW5nIGxpa2UgYFwiNjBzXCJgIGZvciA2MCBzZWNvbmRzLCBgXCIxaDQ1bVwiYCBmb3IgMSBob3VyXG4gKiBhbmQgNDUgbWludXRlcywgb3IgYSBudW1iZXIgbGlrZSBgNjBgIGZvciA2MCBzZWNvbmRzLiBWYWxpZCBzdHJpbmcgdGltZSB1bml0c1xuICogYXJlOlxuICogLSBgc2AgZm9yIHNlY29uZHMuXG4gKiAtIGBtYCBmb3IgbWludXRlcy5cbiAqIC0gYGhgIGZvciBob3Vycy5cbiAqIC0gYGRgIGZvciBkYXlzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlcXVlc3RzIGFsbG93ZWQgaW4gdGhlXG4gKiBzbGlkaW5nIHRpbWUgd2luZG93LlxuICogQHJldHVybnMge1ByaW1pdGl2ZX0gVGhlIHNsaWRpbmcgd2luZG93IHJ1bGUgdG8gcHJvdmlkZSB0byB0aGUgU0RLIGluIHRoZVxuICogYHJ1bGVzYCBvcHRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBzbGlkaW5nV2luZG93KHsgbW9kZTogXCJMSVZFXCIsIGludGVydmFsOiBcIjYwc1wiLCBtYXg6IDEwMCB9KTtcbiAqIGBgYFxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgIGtleTogcHJvY2Vzcy5lbnYuQVJDSkVUX0tFWSxcbiAqICAgcnVsZXM6IFtcbiAqICAgICBzbGlkaW5nV2luZG93KHtcbiAqICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgaW50ZXJ2YWw6IFwiNjBzXCIsXG4gKiAgICAgICBtYXg6IDEwMCxcbiAqICAgICB9KVxuICogICBdLFxuICogfSk7XG4gKiBgYGBcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3JhdGUtbGltaXRpbmcvY29uY2VwdHNcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3JhdGUtbGltaXRpbmcvYWxnb3JpdGhtcyNzbGlkaW5nLXdpbmRvd1xuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vcmF0ZS1saW1pdGluZy9yZWZlcmVuY2VcbiAqL1xuZnVuY3Rpb24gc2xpZGluZ1dpbmRvdyhvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVTbGlkaW5nV2luZG93T3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB0eXBlID0gXCJSQVRFX0xJTUlUXCI7XG4gICAgY29uc3QgdmVyc2lvbiA9IDA7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gXCJMSVZFXCIgPyBcIkxJVkVcIiA6IFwiRFJZX1JVTlwiO1xuICAgIGNvbnN0IGNoYXJhY3RlcmlzdGljcyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5jaGFyYWN0ZXJpc3RpY3MpXG4gICAgICAgID8gb3B0aW9ucy5jaGFyYWN0ZXJpc3RpY3NcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbWF4ID0gb3B0aW9ucy5tYXg7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBkdXJhdGlvbi5wYXJzZShvcHRpb25zLmludGVydmFsKTtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuUmF0ZUxpbWl0LFxuICAgICAgICBtb2RlLFxuICAgICAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgIGFsZ29yaXRobTogXCJTTElESU5HX1dJTkRPV1wiLFxuICAgICAgICBtYXgsXG4gICAgICAgIGludGVydmFsLFxuICAgICAgICB2YWxpZGF0ZSgpIHsgfSxcbiAgICAgICAgYXN5bmMgcHJvdGVjdChjb250ZXh0LCBkZXRhaWxzKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbENoYXJhY3RlcmlzdGljcyA9IGNoYXJhY3RlcmlzdGljcyA/PyBjb250ZXh0LmNoYXJhY3RlcmlzdGljcztcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVJZCA9IGF3YWl0IGhhc2hlci5oYXNoKGhhc2hlci5zdHJpbmcoXCJ0eXBlXCIsIHR5cGUpLCBoYXNoZXIudWludDMyKFwidmVyc2lvblwiLCB2ZXJzaW9uKSwgaGFzaGVyLnN0cmluZyhcIm1vZGVcIiwgbW9kZSksIGhhc2hlci5zdHJpbmcoXCJhbGdvcml0aG1cIiwgXCJTTElESU5HX1dJTkRPV1wiKSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImNoYXJhY3RlcmlzdGljc1wiLCBsb2NhbENoYXJhY3RlcmlzdGljcyksIFxuICAgICAgICAgICAgLy8gTWF0Y2ggaXMgZGVwcmVjYXRlZCBzbyBpdCBpcyBhbHdheXMgYW4gZW1wdHkgc3RyaW5nIGluIHRoZSBuZXdlc3QgU0RLc1xuICAgICAgICAgICAgaGFzaGVyLnN0cmluZyhcIm1hdGNoXCIsIFwiXCIpLCBoYXNoZXIudWludDMyKFwibWF4XCIsIG1heCksIGhhc2hlci51aW50MzIoXCJpbnRlcnZhbFwiLCBpbnRlcnZhbCkpO1xuICAgICAgICAgICAgY29uc3QgYW5hbHl6ZUNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiBsb2NhbENoYXJhY3RlcmlzdGljcyxcbiAgICAgICAgICAgICAgICBsb2c6IGNvbnRleHQubG9nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGZpbmdlcnByaW50ID0gYXdhaXQgYW5hbHl6ZS5nZW5lcmF0ZUZpbmdlcnByaW50KGFuYWx5emVDb250ZXh0LCB0b0FuYWx5emVSZXF1ZXN0KGRldGFpbHMpKTtcbiAgICAgICAgICAgIGNvbnN0IFtjYWNoZWQsIHR0bF0gPSBhd2FpdCBjb250ZXh0LmNhY2hlLmdldChydWxlSWQsIGZpbmdlcnByaW50KTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLnJlYXNvbi5pc1JhdGVMaW1pdCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgdHRsLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJDQUNIRURcIixcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogY2FjaGVkLmNvbmNsdXNpb24sXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHJlYnVpbGQgdGhlIGBBcmNqZXRSYXRlTGltaXRSZWFzb25gIGJlY2F1c2Ugd2UgbmVlZCB0byBhZGp1c3RcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGByZXNldGAgYmFzZWQgb24gdGhlIGN1cnJlbnQgdGltZS10by1saXZlXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldFJhdGVMaW1pdFJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXg6IGNhY2hlZC5yZWFzb24ubWF4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nOiBjYWNoZWQucmVhc29uLnJlbWFpbmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0OiB0dGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IGNhY2hlZC5yZWFzb24ud2luZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRUaW1lOiBjYWNoZWQucmVhc29uLnJlc2V0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgc3RhdGU6IFwiTk9UX1JVTlwiLFxuICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiQUxMT1dcIixcbiAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRSYXRlTGltaXRSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICBtYXg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgcmVzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdzogMCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIFtydWxlXTtcbn1cbmZ1bmN0aW9uIHByb3RvY29sU2Vuc2l0aXZlSW5mb0VudGl0aWVzVG9BbmFseXplKGVudGl0eSkge1xuICAgIGlmICh0eXBlb2YgZW50aXR5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZW50aXR5IHR5cGVcIik7XG4gICAgfVxuICAgIGlmIChlbnRpdHkgPT09IFwiRU1BSUxcIikge1xuICAgICAgICByZXR1cm4geyB0YWc6IFwiZW1haWxcIiB9O1xuICAgIH1cbiAgICBpZiAoZW50aXR5ID09PSBcIlBIT05FX05VTUJFUlwiKSB7XG4gICAgICAgIHJldHVybiB7IHRhZzogXCJwaG9uZS1udW1iZXJcIiB9O1xuICAgIH1cbiAgICBpZiAoZW50aXR5ID09PSBcIklQX0FERFJFU1NcIikge1xuICAgICAgICByZXR1cm4geyB0YWc6IFwiaXAtYWRkcmVzc1wiIH07XG4gICAgfVxuICAgIGlmIChlbnRpdHkgPT09IFwiQ1JFRElUX0NBUkRfTlVNQkVSXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFnOiBcImNyZWRpdC1jYXJkLW51bWJlclwiIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRhZzogXCJjdXN0b21cIixcbiAgICAgICAgdmFsOiBlbnRpdHksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFuYWx5emVTZW5zaXRpdmVJbmZvRW50aXRpZXNUb1N0cmluZyhlbnRpdHkpIHtcbiAgICBpZiAoZW50aXR5LnRhZyA9PT0gXCJlbWFpbFwiKSB7XG4gICAgICAgIHJldHVybiBcIkVNQUlMXCI7XG4gICAgfVxuICAgIGlmIChlbnRpdHkudGFnID09PSBcImlwLWFkZHJlc3NcIikge1xuICAgICAgICByZXR1cm4gXCJJUF9BRERSRVNTXCI7XG4gICAgfVxuICAgIGlmIChlbnRpdHkudGFnID09PSBcImNyZWRpdC1jYXJkLW51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBcIkNSRURJVF9DQVJEX05VTUJFUlwiO1xuICAgIH1cbiAgICBpZiAoZW50aXR5LnRhZyA9PT0gXCJwaG9uZS1udW1iZXJcIikge1xuICAgICAgICByZXR1cm4gXCJQSE9ORV9OVU1CRVJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGVudGl0eS52YWw7XG59XG5mdW5jdGlvbiBjb252ZXJ0QW5hbHl6ZURldGVjdGVkU2Vuc2l0aXZlSW5mb0VudGl0eShkZXRlY3RlZEVudGl0aWVzKSB7XG4gICAgcmV0dXJuIGRldGVjdGVkRW50aXRpZXMubWFwKChkZXRlY3RlZEVudGl0eSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZGV0ZWN0ZWRFbnRpdHksXG4gICAgICAgICAgICBpZGVudGlmaWVkVHlwZTogYW5hbHl6ZVNlbnNpdGl2ZUluZm9FbnRpdGllc1RvU3RyaW5nKGRldGVjdGVkRW50aXR5LmlkZW50aWZpZWRUeXBlKSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8qKlxuICogQXJjamV0IHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiBkZXRlY3Rpb24gcnVsZS4gQXBwbHlpbmcgdGhpcyBydWxlIHByb3RlY3RzXG4gKiBhZ2FpbnN0IGNsaWVudHMgc2VuZGluZyB5b3Ugc2Vuc2l0aXZlIGluZm9ybWF0aW9uIHN1Y2ggYXMgcGVyc29uYWxseVxuICogaWRlbnRpZmlhYmxlIGluZm9ybWF0aW9uIChQSUkpIHRoYXQgeW91IGRvIG5vdCB3aXNoIHRvIGhhbmRsZS4gVGhlIHJ1bGUgcnVuc1xuICogZW50aXJlbHkgbG9jYWxseSBzbyBubyBkYXRhIGV2ZXIgbGVhdmVzIHlvdXIgZW52aXJvbm1lbnQuXG4gKlxuICogVGhpcyBydWxlIGluY2x1ZGVzIGJ1aWx0LWluIGRldGVjdGlvbnMgZm9yIGVtYWlsIGFkZHJlc3NlcywgY3JlZGl0L2RlYml0IGNhcmRcbiAqIG51bWJlcnMsIElQIGFkZHJlc3NlcywgYW5kIHBob25lIG51bWJlcnMuIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgY3VzdG9tXG4gKiBkZXRlY3Rpb24gZnVuY3Rpb24gdG8gaWRlbnRpZnkgYWRkaXRpb25hbCBzZW5zaXRpdmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIHtTZW5zaXRpdmVJbmZvT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgc2Vuc2l0aXZlXG4gKiBpbmZvcm1hdGlvbiBkZXRlY3Rpb24gcnVsZS5cbiAqIEBwYXJhbSB7QXJjamV0TW9kZX0gb3B0aW9ucy5tb2RlIC0gVGhlIGJsb2NrIG1vZGUgb2YgdGhlIHJ1bGUsIGVpdGhlclxuICogYFwiTElWRVwiYCBvciBgXCJEUllfUlVOXCJgLiBgXCJMSVZFXCJgIHdpbGwgYmxvY2sgcmVxdWVzdHMgd2hlbiBhbnkgb2YgdGhlXG4gKiBjb25maWd1cmVkIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiB0eXBlcyBhcmUgZGV0ZWN0ZWQsIGFuZCBgXCJEUllfUlVOXCJgIHdpbGxcbiAqIGFsbG93IGFsbCByZXF1ZXN0cyB3aGlsZSBzdGlsbCBwcm92aWRpbmcgYWNjZXNzIHRvIHRoZSBydWxlIHJlc3VsdHMuIERlZmF1bHRzXG4gKiB0byBgXCJEUllfUlVOXCJgIGlmIG5vdCBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge0FycmF5PEFyY2pldFNlbnNpdGl2ZUluZm9UeXBlPn0gb3B0aW9ucy5kZW55IC0gVGhlIGxpc3Qgb2Ygc2Vuc2l0aXZlXG4gKiBpbmZvcm1hdGlvbiB0eXBlcyB0byBkZW55LiBJZiBwcm92aWRlZCwgdGhlIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiB0eXBlcyBpblxuICogdGhpcyBsaXN0IHdpbGwgYmUgZGVuaWVkLiBZb3UgbWF5IG9ubHkgcHJvdmlkZSBlaXRoZXIgYGFsbG93YCBvciBgZGVueWAsIG5vdFxuICogYm90aC4gU3BlY2lmeSBvbmUgb3IgbW9yZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gYFwiRU1BSUxcImBcbiAqIC0gYFwiUEhPTkVfTlVNQkVSXCJgXG4gKiAtIGBcIklQX0FERFJFU1NcImBcbiAqIC0gYFwiQ1JFRElUX0NBUkRfTlVNQkVSXCJgXG4gKiBAcGFyYW0ge0FycmF5PEFyY2pldFNlbnNpdGl2ZUluZm9UeXBlPn0gb3B0aW9ucy5hbGxvdyAtIFRoZSBsaXN0IG9mIHNlbnNpdGl2ZVxuICogaW5mb3JtYXRpb24gdHlwZXMgdG8gYWxsb3cuIElmIHByb3ZpZGVkLCB0eXBlcyBpbiB0aGlzIGxpc3Qgd2lsbCBiZSBhbGxvd2VkXG4gKiBhbmQgYWxsIG90aGVycyB3aWxsIGJlIGRlbmllZC4gWW91IG1heSBvbmx5IHByb3ZpZGUgZWl0aGVyIGBhbGxvd2Agb3IgYGRlbnlgLFxuICogbm90IGJvdGguIFRoZSBzYW1lIG9wdGlvbnMgYXBwbHkgYXMgZm9yIGBkZW55YC5cbiAqIEBwYXJhbSB7RGV0ZWN0U2Vuc2l0aXZlSW5mb0VudGl0aWVzfSBvcHRpb25zLmRldGVjdCAtIEEgY3VzdG9tIGRldGVjdGlvblxuICogZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiB3aWxsIHRha2UgYSBsaXN0IG9mIHRva2VucyBhbmQgbXVzdCByZXR1cm4gYSBsaXN0IG9mXG4gKiBlaXRoZXIgYHVuZGVmaW5lZGAsIGlmIHRoZSBjb3JyZXNwb25kaW5nIHRva2VuIGluIHRoZSBpbnB1dCBsaXN0IGlzIG5vdFxuICogc2Vuc2l0aXZlLCBvciB0aGUgbmFtZSBvZiB0aGUgZW50aXR5IGlmIGl0IGRvZXMgbWF0Y2guIFRoZSBudW1iZXIgb2YgdG9rZW5zXG4gKiB0aGF0IGFyZSBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gaXMgY29udHJvbGxlZCBieSB0aGUgYGNvbnRleHRXaW5kb3dTaXplYFxuICogb3B0aW9uLCB3aGljaCBkZWZhdWx0cyB0byBgMWAuIElmIHlvdSBuZWVkIGFkZGl0aW9uYWwgY29udGV4dCB0byBwZXJmb3JtXG4gKiBkZXRlY3Rpb25zIHRoZW4geW91IGNhbiBpbmNyZWFzZSB0aGlzIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY29udGV4dFdpbmRvd1NpemUgLSBUaGUgbnVtYmVyIG9mIHRva2VucyB0byBwcm92aWRlXG4gKiB0byB0aGUgY3VzdG9tIGRldGVjdGlvbiBmdW5jdGlvbi4gVGhpcyBkZWZhdWx0cyB0byAxIGlmIG5vdCBzcGVjaWZpZWQuXG4gKiBAcmV0dXJucyB7UHJpbWl0aXZlfSBUaGUgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIHJ1bGUgdG8gcHJvdmlkZSB0byB0aGUgU0RLIGluXG4gKiB0aGUgYHJ1bGVzYCBvcHRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBzZW5zaXRpdmVJbmZvKHsgbW9kZTogXCJMSVZFXCIsIGRlbnk6IFtcIkVNQUlMXCJdIH0pO1xuICogYGBgXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICBydWxlczogW1xuICogICAgIHNlbnNpdGl2ZUluZm8oe1xuICogICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICBkZW55OiBbXCJFTUFJTFwiXSxcbiAqICAgICB9KVxuICogICBdLFxuICogfSk7XG4gKiBgYGBcbiAqIEBleGFtcGxlXG4gKiBDdXN0b20gZGV0ZWN0aW9uIGZ1bmN0aW9uOlxuICogYGBgdHNcbiAqIGZ1bmN0aW9uIGRldGVjdERhc2godG9rZW5zOiBzdHJpbmdbXSk6IEFycmF5PFwiQ09OVEFJTlNfREFTSFwiIHwgdW5kZWZpbmVkPiB7XG4gKiAgIHJldHVybiB0b2tlbnMubWFwKCh0b2tlbikgPT4ge1xuICogICAgIGlmICh0b2tlbi5pbmNsdWRlcyhcIi1cIikpIHtcbiAqICAgICAgIHJldHVybiBcIkNPTlRBSU5TX0RBU0hcIjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICogfVxuICpcbiAqIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICBydWxlczogW1xuICogICAgIHNlbnNpdGl2ZUluZm8oe1xuICogICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICBkZW55OiBbXCJFTUFJTFwiLCBcIkNPTlRBSU5TX0RBU0hcIl0sXG4gKiAgICAgICBkZXRlY3Q6IGRldGVjdERhc2gsXG4gKiAgICAgICBjb250ZXh0V2luZG93U2l6ZTogMixcbiAqICAgICB9KVxuICogICBdLFxuICogfSk7XG4gKiBgYGBcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3NlbnNpdGl2ZS1pbmZvL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9zZW5zaXRpdmUtaW5mby9yZWZlcmVuY2VcbiAqL1xuZnVuY3Rpb24gc2Vuc2l0aXZlSW5mbyhvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVTZW5zaXRpdmVJbmZvT3B0aW9ucyhvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxsb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuZGVueSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgc2Vuc2l0aXZlSW5mb2Agb3B0aW9ucyBlcnJvcjogYGFsbG93YCBhbmQgYGRlbnlgIGNhbm5vdCBiZSBwcm92aWRlZCB0b2dldGhlclwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmRlbnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHNlbnNpdGl2ZUluZm9gIG9wdGlvbnMgZXJyb3I6IGVpdGhlciBgYWxsb3dgIG9yIGBkZW55YCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IFwiU0VOU0lUSVZFX0lORk9cIjtcbiAgICBjb25zdCB2ZXJzaW9uID0gMDtcbiAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5tb2RlID09PSBcIkxJVkVcIiA/IFwiTElWRVwiIDogXCJEUllfUlVOXCI7XG4gICAgY29uc3QgYWxsb3cgPSBvcHRpb25zLmFsbG93IHx8IFtdO1xuICAgIGNvbnN0IGRlbnkgPSBvcHRpb25zLmRlbnkgfHwgW107XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5LlNlbnNpdGl2ZUluZm8sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGFsbG93LFxuICAgICAgICBkZW55LFxuICAgICAgICB2YWxpZGF0ZShjb250ZXh0LCBkZXRhaWxzKSB7IH0sXG4gICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgZGV0YWlscykge1xuICAgICAgICAgICAgY29uc3QgcnVsZUlkID0gYXdhaXQgaGFzaGVyLmhhc2goaGFzaGVyLnN0cmluZyhcInR5cGVcIiwgdHlwZSksIGhhc2hlci51aW50MzIoXCJ2ZXJzaW9uXCIsIHZlcnNpb24pLCBoYXNoZXIuc3RyaW5nKFwibW9kZVwiLCBtb2RlKSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImFsbG93XCIsIGFsbG93KSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImRlbnlcIiwgZGVueSkpO1xuICAgICAgICAgICAgY29uc3QgeyBmaW5nZXJwcmludCB9ID0gY29udGV4dDtcbiAgICAgICAgICAgIC8vIE5vIGNhY2hlIGlzIGltcGxlbWVudGVkIGhlcmUgYmVjYXVzZSB0aGUgZmluZ2VycHJpbnQgY2FuIGJlIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyB3aGlsZSB0aGUgcmVxdWVzdCBib2R5IGNoYW5nZXMuIFRoaXMgaXMgYWxzbyB3aHkgdGhlIGBzZW5zaXRpdmVJbmZvYFxuICAgICAgICAgICAgLy8gcnVsZSByZXN1bHRzIGFsd2F5cyBoYXZlIGEgYHR0bGAgb2YgMC5cbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCBjb250ZXh0LmdldEJvZHkoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiTk9UX1JVTlwiLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkVSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKFwiQ291bGRuJ3QgcmVhZCB0aGUgYm9keSBvZiB0aGUgcmVxdWVzdCB0byBwZXJmb3JtIHNlbnNpdGl2ZSBpbmZvIGlkZW50aWZpY2F0aW9uLlwiKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb252ZXJ0ZWREZXRlY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGV0ZWN0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV0ZWN0ID0gb3B0aW9ucy5kZXRlY3Q7XG4gICAgICAgICAgICAgICAgY29udmVydGVkRGV0ZWN0ID0gKHRva2VucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV0ZWN0KHRva2VucylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGUpID0+IHR5cGVvZiBlICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChwcm90b2NvbFNlbnNpdGl2ZUluZm9FbnRpdGllc1RvQW5hbHl6ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbnRpdGllc1RhZyA9IFwiYWxsb3dcIjtcbiAgICAgICAgICAgIGxldCBlbnRpdGllc1ZhbCA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5hbGxvdykpIHtcbiAgICAgICAgICAgICAgICBlbnRpdGllc1RhZyA9IFwiYWxsb3dcIjtcbiAgICAgICAgICAgICAgICBlbnRpdGllc1ZhbCA9IG9wdGlvbnMuYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZSkgPT4gdHlwZW9mIGUgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAocHJvdG9jb2xTZW5zaXRpdmVJbmZvRW50aXRpZXNUb0FuYWx5emUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5kZW55KSkge1xuICAgICAgICAgICAgICAgIGVudGl0aWVzVGFnID0gXCJkZW55XCI7XG4gICAgICAgICAgICAgICAgZW50aXRpZXNWYWwgPSBvcHRpb25zLmRlbnlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZSkgPT4gdHlwZW9mIGUgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAocHJvdG9jb2xTZW5zaXRpdmVJbmZvRW50aXRpZXNUb0FuYWx5emUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZW50aXRpZXMgPSB7XG4gICAgICAgICAgICAgICAgdGFnOiBlbnRpdGllc1RhZyxcbiAgICAgICAgICAgICAgICB2YWw6IGVudGl0aWVzVmFsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFuYWx5emUuZGV0ZWN0U2Vuc2l0aXZlSW5mbyhjb250ZXh0LCBib2R5LCBlbnRpdGllcywgb3B0aW9ucy5jb250ZXh0V2luZG93U2l6ZSB8fCAxLCBjb252ZXJ0ZWREZXRlY3QpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBtb2RlID09PSBcIkxJVkVcIiA/IFwiUlVOXCIgOiBcIkRSWV9SVU5cIjtcbiAgICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IG5ldyBBcmNqZXRTZW5zaXRpdmVJbmZvUmVhc29uKHtcbiAgICAgICAgICAgICAgICBkZW5pZWQ6IGNvbnZlcnRBbmFseXplRGV0ZWN0ZWRTZW5zaXRpdmVJbmZvRW50aXR5KHJlc3VsdC5kZW5pZWQpLFxuICAgICAgICAgICAgICAgIGFsbG93ZWQ6IGNvbnZlcnRBbmFseXplRGV0ZWN0ZWRTZW5zaXRpdmVJbmZvRW50aXR5KHJlc3VsdC5hbGxvd2VkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kZW5pZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJBTExPV1wiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkRFTllcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIFtydWxlXTtcbn1cbi8qKlxuICogQXJjamV0IGVtYWlsIHZhbGlkYXRpb24gcnVsZS4gQXBwbHlpbmcgdGhpcyBydWxlIGFsbG93cyB5b3UgdG8gdmFsaWRhdGUgJlxuICogdmVyaWZ5IGFuIGVtYWlsIGFkZHJlc3MuXG4gKlxuICogVGhlIGZpcnN0IHN0ZXAgb2YgdGhlIGFuYWx5c2lzIGlzIHRvIHZhbGlkYXRlIHRoZSBlbWFpbCBhZGRyZXNzIHN5bnRheC4gVGhpc1xuICogcnVucyBsb2NhbGx5IHdpdGhpbiB0aGUgU0RLIGFuZCB2YWxpZGF0ZXMgdGhlIGVtYWlsIGFkZHJlc3MgaXMgaW4gdGhlIGNvcnJlY3RcbiAqIGZvcm1hdC4gSWYgdGhlIGVtYWlsIHN5bnRheCBpcyB2YWxpZCwgdGhlIFNESyB3aWxsIHBhc3MgdGhlIGVtYWlsIGFkZHJlc3MgdG9cbiAqIHRoZSBBcmNqZXQgY2xvdWQgQVBJIHRvIHZlcmlmeSB0aGUgZW1haWwgYWRkcmVzcy4gVGhpcyBwZXJmb3JtcyBzZXZlcmFsXG4gKiBjaGVja3MsIGRlcGVuZGluZyBvbiB0aGUgcnVsZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7RW1haWxPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBlbWFpbCB2YWxpZGF0aW9uIHJ1bGUuXG4gKiBAcGFyYW0ge0FyY2pldE1vZGV9IG9wdGlvbnMubW9kZSAtIFRoZSBibG9jayBtb2RlIG9mIHRoZSBydWxlLCBlaXRoZXJcbiAqIGBcIkxJVkVcImAgb3IgYFwiRFJZX1JVTlwiYC4gYFwiTElWRVwiYCB3aWxsIGJsb2NrIGVtYWlsIGFkZHJlc3NlcyBiYXNlZCBvbiB0aGVcbiAqIGNvbmZpZ3VyYXRpb24sIGFuZCBgXCJEUllfUlVOXCJgIHdpbGwgYWxsb3cgYWxsIHJlcXVlc3RzIHdoaWxlIHN0aWxsIHByb3ZpZGluZ1xuICogYWNjZXNzIHRvIHRoZSBydWxlIHJlc3VsdHMuIERlZmF1bHRzIHRvIGBcIkRSWV9SVU5cImAgaWYgbm90IHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJjamV0RW1haWxUeXBlPn0gb3B0aW9ucy5kZW55IC0gVGhlIGxpc3Qgb2YgZW1haWwgdHlwZXMgdG9cbiAqIGRlbnkuIElmIHByb3ZpZGVkLCB0aGUgZW1haWwgdHlwZXMgaW4gdGhpcyBsaXN0IHdpbGwgYmUgZGVuaWVkLiBZb3UgbWF5IG9ubHlcbiAqIHByb3ZpZGUgZWl0aGVyIGBhbGxvd2Agb3IgYGRlbnlgLCBub3QgYm90aC4gU3BlY2lmeSBvbmUgb3IgbW9yZSBvZiB0aGVcbiAqIGZvbGxvd2luZzpcbiAqXG4gKiAtIGBcIkRJU1BPU0FCTEVcImAgLSBEaXNwb3NhYmxlIGVtYWlsIGFkZHJlc3Nlcy5cbiAqIC0gYFwiRlJFRVwiYCAtIEZyZWUgZW1haWwgYWRkcmVzc2VzLlxuICogLSBgXCJOT19NWF9SRUNPUkRTXCJgIC0gRW1haWwgYWRkcmVzc2VzIHdpdGggbm8gTVggcmVjb3Jkcy5cbiAqIC0gYFwiTk9fR1JBVkFUQVJcImAgLSBFbWFpbCBhZGRyZXNzZXMgd2l0aCBubyBHcmF2YXRhci5cbiAqIC0gYFwiSU5WQUxJRFwiYCAtIEludmFsaWQgZW1haWwgYWRkcmVzc2VzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJjamV0RW1haWxUeXBlPn0gb3B0aW9ucy5hbGxvdyAtIFRoZSBsaXN0IG9mIGVtYWlsIHR5cGVzIHRvXG4gKiBhbGxvdy4gSWYgcHJvdmlkZWQsIGVtYWlsIGFkZHJlc3NlcyBpbiB0aGlzIGxpc3Qgd2lsbCBiZSBhbGxvd2VkIGFuZCBhbGxcbiAqIG90aGVycyB3aWxsIGJlIGRlbmllZC4gWW91IG1heSBvbmx5IHByb3ZpZGUgZWl0aGVyIGBhbGxvd2Agb3IgYGRlbnlgLCBub3RcbiAqIGJvdGguIFRoZSBzYW1lIG9wdGlvbnMgYXBwbHkgYXMgZm9yIGBkZW55YC5cbiAqIEByZXR1cm5zIHtQcmltaXRpdmV9IFRoZSBlbWFpbCBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpbiB0aGUgYHJ1bGVzYFxuICogb3B0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogdmFsaWRhdGVFbWFpbCh7IG1vZGU6IFwiTElWRVwiLCBkZW55OiBbXCJESVNQT1NBQkxFXCIsIFwiSU5WQUxJRFwiXSB9KTtcbiAqIGBgYFxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgIGtleTogcHJvY2Vzcy5lbnYuQVJDSkVUX0tFWSxcbiAqICAgcnVsZXM6IFtcbiAqICAgICB2YWxpZGF0ZUVtYWlsKHtcbiAqICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgZGVueTogW1wiRElTUE9TQUJMRVwiLCBcIklOVkFMSURcIl1cbiAqICAgICB9KVxuICogICBdLFxuICogfSk7XG4gKiBgYGBcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL2VtYWlsLXZhbGlkYXRpb24vY29uY2VwdHNcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL2VtYWlsLXZhbGlkYXRpb24vcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRW1haWwob3B0aW9ucykge1xuICAgIHZhbGlkYXRlRW1haWxPcHRpb25zKG9wdGlvbnMpO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5kZW55ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImB2YWxpZGF0ZUVtYWlsYCBvcHRpb25zIGVycm9yOiBgYWxsb3dgIGFuZCBgZGVueWAgY2Fubm90IGJlIHByb3ZpZGVkIHRvZ2V0aGVyXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxsb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmxvY2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHZhbGlkYXRlRW1haWxgIG9wdGlvbnMgZXJyb3I6IGBhbGxvd2AgYW5kIGBibG9ja2AgY2Fubm90IGJlIHByb3ZpZGVkIHRvZ2V0aGVyXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVueSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5ibG9jayAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdmFsaWRhdGVFbWFpbGAgb3B0aW9ucyBlcnJvcjogYGRlbnlgIGFuZCBgYmxvY2tgIGNhbm5vdCBiZSBwcm92aWRlZCB0b2dldGhlciwgYGJsb2NrYCBpcyBub3cgZGVwcmVjYXRlZCBzbyBgZGVueWAgc2hvdWxkIGJlIHByZWZlcnJlZC5cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5kZW55ID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmJsb2NrID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImB2YWxpZGF0ZUVtYWlsYCBvcHRpb25zIGVycm9yOiBlaXRoZXIgYGFsbG93YCBvciBgZGVueWAgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBcIkVNQUlMXCI7XG4gICAgY29uc3QgdmVyc2lvbiA9IDA7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gXCJMSVZFXCIgPyBcIkxJVkVcIiA6IFwiRFJZX1JVTlwiO1xuICAgIGNvbnN0IGFsbG93ID0gb3B0aW9ucy5hbGxvdyA/PyBbXTtcbiAgICBjb25zdCBkZW55ID0gb3B0aW9ucy5kZW55ID8/IG9wdGlvbnMuYmxvY2sgPz8gW107XG4gICAgY29uc3QgcmVxdWlyZVRvcExldmVsRG9tYWluID0gb3B0aW9ucy5yZXF1aXJlVG9wTGV2ZWxEb21haW4gPz8gdHJ1ZTtcbiAgICBjb25zdCBhbGxvd0RvbWFpbkxpdGVyYWwgPSBvcHRpb25zLmFsbG93RG9tYWluTGl0ZXJhbCA/PyBmYWxzZTtcbiAgICBsZXQgY29uZmlnID0ge1xuICAgICAgICB0YWc6IFwiZGVueS1lbWFpbC12YWxpZGF0aW9uLWNvbmZpZ1wiLFxuICAgICAgICB2YWw6IHtcbiAgICAgICAgICAgIHJlcXVpcmVUb3BMZXZlbERvbWFpbixcbiAgICAgICAgICAgIGFsbG93RG9tYWluTGl0ZXJhbCxcbiAgICAgICAgICAgIGRlbnk6IFtdLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRhZzogXCJhbGxvdy1lbWFpbC12YWxpZGF0aW9uLWNvbmZpZ1wiLFxuICAgICAgICAgICAgdmFsOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZVRvcExldmVsRG9tYWluLFxuICAgICAgICAgICAgICAgIGFsbG93RG9tYWluTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICBhbGxvdzogb3B0aW9ucy5hbGxvdyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZW55ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRhZzogXCJkZW55LWVtYWlsLXZhbGlkYXRpb24tY29uZmlnXCIsXG4gICAgICAgICAgICB2YWw6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlVG9wTGV2ZWxEb21haW4sXG4gICAgICAgICAgICAgICAgYWxsb3dEb21haW5MaXRlcmFsLFxuICAgICAgICAgICAgICAgIGRlbnk6IG9wdGlvbnMuZGVueSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ibG9jayAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICB0YWc6IFwiZGVueS1lbWFpbC12YWxpZGF0aW9uLWNvbmZpZ1wiLFxuICAgICAgICAgICAgdmFsOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZVRvcExldmVsRG9tYWluLFxuICAgICAgICAgICAgICAgIGFsbG93RG9tYWluTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICBkZW55OiBvcHRpb25zLmJsb2NrLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5LkVtYWlsVmFsaWRhdGlvbixcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgYWxsb3csXG4gICAgICAgIGRlbnksXG4gICAgICAgIHJlcXVpcmVUb3BMZXZlbERvbWFpbixcbiAgICAgICAgYWxsb3dEb21haW5MaXRlcmFsLFxuICAgICAgICB2YWxpZGF0ZShjb250ZXh0LCBkZXRhaWxzKSB7XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIGRldGFpbHMuZW1haWwgIT09IFwidW5kZWZpbmVkXCIsIFwiVmFsaWRhdGVFbWFpbCByZXF1aXJlcyBgZW1haWxgIHRvIGJlIHNldC5cIik7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgeyBlbWFpbCB9KSB7XG4gICAgICAgICAgICBjb25zdCBydWxlSWQgPSBhd2FpdCBoYXNoZXIuaGFzaChoYXNoZXIuc3RyaW5nKFwidHlwZVwiLCB0eXBlKSwgaGFzaGVyLnVpbnQzMihcInZlcnNpb25cIiwgdmVyc2lvbiksIGhhc2hlci5zdHJpbmcoXCJtb2RlXCIsIG1vZGUpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiYWxsb3dcIiwgYWxsb3cpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiZGVueVwiLCBkZW55KSwgaGFzaGVyLmJvb2woXCJyZXF1aXJlVG9wTGV2ZWxEb21haW5cIiwgcmVxdWlyZVRvcExldmVsRG9tYWluKSwgaGFzaGVyLmJvb2woXCJhbGxvd0RvbWFpbkxpdGVyYWxcIiwgYWxsb3dEb21haW5MaXRlcmFsKSk7XG4gICAgICAgICAgICBjb25zdCB7IGZpbmdlcnByaW50IH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgLy8gTm8gY2FjaGUgaXMgaW1wbGVtZW50ZWQgaGVyZSBiZWNhdXNlIHRoZSBmaW5nZXJwcmludCBjYW4gYmUgdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIHdoaWxlIHRoZSBlbWFpbCBjaGFuZ2VzLiBUaGlzIGlzIGFsc28gd2h5IHRoZSBgZW1haWxgIHJ1bGUgcmVzdWx0c1xuICAgICAgICAgICAgLy8gYWx3YXlzIGhhdmUgYSBgdHRsYCBvZiAwLlxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYW5hbHl6ZS5pc1ZhbGlkRW1haWwoY29udGV4dCwgZW1haWwsIGNvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IG1vZGUgPT09IFwiTElWRVwiID8gXCJSVU5cIiA6IFwiRFJZX1JVTlwiO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52YWxpZGl0eSA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJBTExPV1wiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRFbWFpbFJlYXNvbih7IGVtYWlsVHlwZXM6IFtdIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRFbWFpbFR5cGVzID0gcmVzdWx0LmJsb2NrZWQuZmlsdGVyKGlzRW1haWxUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkRFTllcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0RW1haWxSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1haWxUeXBlczogdHlwZWRFbWFpbFR5cGVzLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBbcnVsZV07XG59XG4vKipcbiAqIEFyY2pldCBib3QgZGV0ZWN0aW9uIHJ1bGUuIEFwcGx5aW5nIHRoaXMgcnVsZSBhbGxvd3MgeW91IHRvIG1hbmFnZSB0cmFmZmljIGJ5XG4gKiBhdXRvbWF0ZWQgY2xpZW50cyBhbmQgYm90cy5cbiAqXG4gKiBCb3RzIGNhbiBiZSBnb29kIChzdWNoIGFzIHNlYXJjaCBlbmdpbmUgY3Jhd2xlcnMgb3IgbW9uaXRvcmluZyBhZ2VudHMpIG9yIGJhZFxuICogKHN1Y2ggYXMgc2NyYXBlcnMgb3IgYXV0b21hdGVkIHNjcmlwdHMpLiBBcmNqZXQgYWxsb3dzIHlvdSB0byBjb25maWd1cmUgd2hpY2hcbiAqIGJvdHMgeW91IHdhbnQgdG8gYWxsb3cgb3IgZGVueSBieSBzcGVjaWZpYyBib3QgbmFtZXMgZS5nLiBjdXJsLCBhcyB3ZWxsIGFzIGJ5XG4gKiBjYXRlZ29yeSBlLmcuIHNlYXJjaCBlbmdpbmUgYm90cy5cbiAqXG4gKiBCb3RzIGFyZSBkZXRlY3RlZCBiYXNlZCBvbiB2YXJpb3VzIHNpZ25hbHMgc3VjaCBhcyB0aGUgdXNlciBhZ2VudCwgSVBcbiAqIGFkZHJlc3MsIEROUyByZWNvcmRzLCBhbmQgbW9yZS5cbiAqXG4gKiBAcGFyYW0ge0JvdE9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGJvdCBydWxlLlxuICogQHBhcmFtIHtBcmNqZXRNb2RlfSBvcHRpb25zLm1vZGUgLSBUaGUgYmxvY2sgbW9kZSBvZiB0aGUgcnVsZSwgZWl0aGVyXG4gKiBgXCJMSVZFXCJgIG9yIGBcIkRSWV9SVU5cImAuIGBcIkxJVkVcImAgd2lsbCBibG9jayBkZXRlY3RlZCBib3RzLCBhbmQgYFwiRFJZX1JVTlwiYFxuICogd2lsbCBhbGxvdyBhbGwgcmVxdWVzdHMgd2hpbGUgc3RpbGwgcHJvdmlkaW5nIGFjY2VzcyB0byB0aGUgcnVsZSByZXN1bHRzLlxuICogRGVmYXVsdHMgdG8gYFwiRFJZX1JVTlwiYCBpZiBub3Qgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtBcnJheTxBcmNqZXRXZWxsS25vd25Cb3QgfCBBcmNqZXRCb3RDYXRlZ29yeT59IG9wdGlvbnMuYWxsb3cgLSBUaGVcbiAqIGxpc3Qgb2YgYm90cyB0byBhbGxvdy4gSWYgcHJvdmlkZWQsIG9ubHkgdGhlIGJvdHMgaW4gdGhpcyBsaXN0IHdpbGwgYmVcbiAqIGFsbG93ZWQgYW5kIGFueSBvdGhlciBkZXRlY3RlZCBib3Qgd2lsbCBiZSBkZW5pZWQuIElmIGVtcHR5LCBhbGwgYm90cyB3aWxsIGJlXG4gKiBkZW5pZWQuIFlvdSBtYXkgb25seSBwcm92aWRlIGVpdGhlciBgYWxsb3dgIG9yIGBkZW55YCwgbm90IGJvdGguIFlvdSBjYW4gdXNlXG4gKiBzcGVjaWZpYyBib3RzIGUuZy4gYFwiQ1VSTFwiYCB3aWxsIGFsbG93IHRoZSBkZWZhdWx0IHVzZXItYWdlbnQgb2YgdGhlIGBjdXJsYFxuICogdG9vbC4gWW91IGNhbiBhbHNvIHVzZSBjYXRlZ29yaWVzIGUuZy4gYFwiQ0FURUdPUlk6U0VBUkNIX0VOR0lORVwiYCB3aWxsIGFsbG93XG4gKiBhbGwgc2VhcmNoIGVuZ2luZSBib3RzLiBTZWVcbiAqIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL2JvdC1wcm90ZWN0aW9uL2lkZW50aWZ5aW5nLWJvdHMgZm9yIHRoZSBmdWxsIGxpc3Qgb2ZcbiAqIGJvdHMgYW5kIGNhdGVnb3JpZXMuXG4gKiBAcGFyYW0ge0FycmF5PEFyY2pldFdlbGxLbm93bkJvdCB8IEFyY2pldEJvdENhdGVnb3J5Pn0gb3B0aW9ucy5kZW55IC0gVGhlXG4gKiBsaXN0IG9mIGJvdHMgdG8gZGVueS4gSWYgcHJvdmlkZWQsIHRoZSBib3RzIGluIHRoaXMgbGlzdCB3aWxsIGJlIGRlbmllZCBhbmRcbiAqIGFsbCBvdGhlciBkZXRlY3RlZCBib3RzIHdpbGwgYmUgYWxsb3dlZC4gWW91IG1heSBvbmx5IHByb3ZpZGUgZWl0aGVyIGBhbGxvd2BcbiAqIG9yIGBkZW55YCwgbm90IGJvdGguIFRoZSBzYW1lIG9wdGlvbnMgYXBwbHkgYXMgZm9yIGBhbGxvd2AuXG4gKiBAcmV0dXJucyB7UHJpbWl0aXZlfSBUaGUgYm90IHJ1bGUgdG8gcHJvdmlkZSB0byB0aGUgU0RLIGluIHRoZSBgcnVsZXNgXG4gKiBvcHRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIEFsbG93cyBzZWFyY2ggZW5naW5lIGJvdHMgYW5kIGN1cmwsIGRlbmllcyBhbGwgb3RoZXIgYm90c1xuICpcbiAqIGBgYHRzXG4gKiBkZXRlY3RCb3QoeyBtb2RlOiBcIkxJVkVcIiwgYWxsb3c6IFtcIkNBVEVHT1JZOlNFQVJDSF9FTkdJTkVcIiwgXCJDVVJMXCJdIH0pO1xuICogYGBgXG4gKiBAZXhhbXBsZVxuICogQWxsb3dzIHNlYXJjaCBlbmdpbmUgYm90cyBhbmQgY3VybCwgZGVuaWVzIGFsbCBvdGhlciBib3RzXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICBydWxlczogW1xuICogICAgIGRldGVjdEJvdCh7XG4gKiAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgIGFsbG93OiBbXCJDQVRFR09SWTpTRUFSQ0hfRU5HSU5FXCIsIFwiQ1VSTFwiXVxuICogICAgIH0pXG4gKiAgIF0sXG4gKiB9KTtcbiAqIGBgYFxuICogQGV4YW1wbGVcbiAqIERlbmllcyBBSSBjcmF3bGVycywgYWxsb3dzIGFsbCBvdGhlciBib3RzXG4gKlxuICogYGBgdHNcbiAqIGRldGVjdEJvdCh7IG1vZGU6IFwiTElWRVwiLCBkZW55OiBbXCJDQVRFR09SWTpBSVwiXSB9KTtcbiAqIGBgYFxuICogQGV4YW1wbGVcbiAqIERlbmllcyBBSSBjcmF3bGVycywgYWxsb3dzIGFsbCBvdGhlciBib3RzXG4gKiBgYGB0c1xuICogY29uc3QgYWogPSBhcmNqZXQoe1xuICogICBrZXk6IHByb2Nlc3MuZW52LkFSQ0pFVF9LRVksXG4gKiAgIHJ1bGVzOiBbXG4gKiAgICAgZGV0ZWN0Qm90KHtcbiAqICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgZGVueTogW1wiQ0FURUdPUlk6QUlcIl1cbiAqICAgICB9KVxuICogICBdLFxuICogfSk7XG4gKiBgYGBcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL2JvdC1wcm90ZWN0aW9uL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9ib3QtcHJvdGVjdGlvbi9pZGVudGlmeWluZy1ib3RzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9ib3QtcHJvdGVjdGlvbi9yZWZlcmVuY2VcbiAqL1xuZnVuY3Rpb24gZGV0ZWN0Qm90KG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZUJvdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmRlbnkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGRldGVjdEJvdGAgb3B0aW9ucyBlcnJvcjogYGFsbG93YCBhbmQgYGRlbnlgIGNhbm5vdCBiZSBwcm92aWRlZCB0b2dldGhlclwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmRlbnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGRldGVjdEJvdGAgb3B0aW9ucyBlcnJvcjogZWl0aGVyIGBhbGxvd2Agb3IgYGRlbnlgIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gXCJCT1RcIjtcbiAgICBjb25zdCB2ZXJzaW9uID0gMDtcbiAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5tb2RlID09PSBcIkxJVkVcIiA/IFwiTElWRVwiIDogXCJEUllfUlVOXCI7XG4gICAgY29uc3QgYWxsb3cgPSBvcHRpb25zLmFsbG93ID8/IFtdO1xuICAgIGNvbnN0IGRlbnkgPSBvcHRpb25zLmRlbnkgPz8gW107XG4gICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgICAgdGFnOiBcImFsbG93ZWQtYm90LWNvbmZpZ1wiLFxuICAgICAgICB2YWw6IHtcbiAgICAgICAgICAgIGVudGl0aWVzOiBbXSxcbiAgICAgICAgICAgIHNraXBDdXN0b21EZXRlY3Q6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxsb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgdGFnOiBcImFsbG93ZWQtYm90LWNvbmZpZ1wiLFxuICAgICAgICAgICAgdmFsOiB7XG4gICAgICAgICAgICAgICAgZW50aXRpZXM6IG9wdGlvbnMuYWxsb3csXG4gICAgICAgICAgICAgICAgc2tpcEN1c3RvbURldGVjdDogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZW55ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRhZzogXCJkZW5pZWQtYm90LWNvbmZpZ1wiLFxuICAgICAgICAgICAgdmFsOiB7XG4gICAgICAgICAgICAgICAgZW50aXRpZXM6IG9wdGlvbnMuZGVueSxcbiAgICAgICAgICAgICAgICBza2lwQ3VzdG9tRGV0ZWN0OiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5LkJvdERldGVjdGlvbixcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgYWxsb3csXG4gICAgICAgIGRlbnksXG4gICAgICAgIHZhbGlkYXRlKGNvbnRleHQsIGRldGFpbHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGV0YWlscy5oZWFkZXJzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYm90IGRldGVjdGlvbiByZXF1aXJlcyBgaGVhZGVyc2AgdG8gYmUgc2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXRhaWxzLmhlYWRlcnMuaGFzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJib3QgZGV0ZWN0aW9uIHJlcXVpcmVzIGBoZWFkZXJzYCB0byBleHRlbmQgYEhlYWRlcnNgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXRhaWxzLmhlYWRlcnMuaGFzKFwidXNlci1hZ2VudFwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJvdCBkZXRlY3Rpb24gcmVxdWlyZXMgdXNlci1hZ2VudCBoZWFkZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRlbXB0cyB0byBjYWxsIHRoZSBib3QgZGV0ZWN0aW9uIG9uIHRoZSBoZWFkZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcHJvdGVjdChjb250ZXh0LCByZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCBydWxlSWQgPSBhd2FpdCBoYXNoZXIuaGFzaChoYXNoZXIuc3RyaW5nKFwidHlwZVwiLCB0eXBlKSwgaGFzaGVyLnVpbnQzMihcInZlcnNpb25cIiwgdmVyc2lvbiksIGhhc2hlci5zdHJpbmcoXCJtb2RlXCIsIG1vZGUpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiYWxsb3dcIiwgYWxsb3cpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiZGVueVwiLCBkZW55KSk7XG4gICAgICAgICAgICBjb25zdCB7IGZpbmdlcnByaW50IH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgY29uc3QgW2NhY2hlZCwgdHRsXSA9IGF3YWl0IGNvbnRleHQuY2FjaGUuZ2V0KHJ1bGVJZCwgZmluZ2VycHJpbnQpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHR0bCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiQ0FDSEVEXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IGNhY2hlZC5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IGNhY2hlZC5yZWFzb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbmFseXplLmRldGVjdEJvdChjb250ZXh0LCB0b0FuYWx5emVSZXF1ZXN0KHJlcXVlc3QpLCBjb25maWcpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBtb2RlID09PSBcIkxJVkVcIiA/IFwiUlVOXCIgOiBcIkRSWV9SVU5cIjtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBib3QgYW5kIG9mIGEgdHlwZSB0aGF0IHdlIHdhbnQgdG8gYmxvY2ssIHRoZW4gYmxvY2shXG4gICAgICAgICAgICBpZiAocmVzdWx0LmRlbmllZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgdHRsOiA2MCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiREVOWVwiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRCb3RSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZDogcmVzdWx0LmFsbG93ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5pZWQ6IHJlc3VsdC5kZW5pZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZmllZDogcmVzdWx0LnZlcmlmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Bvb2ZlZDogcmVzdWx0LnNwb29mZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJBTExPV1wiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRCb3RSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZDogcmVzdWx0LmFsbG93ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5pZWQ6IHJlc3VsdC5kZW5pZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZmllZDogcmVzdWx0LnZlcmlmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Bvb2ZlZDogcmVzdWx0LnNwb29mZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIFtydWxlXTtcbn1cbi8qKlxuICogQXJjamV0IFNoaWVsZCBXQUYgcnVsZS4gQXBwbHlpbmcgdGhpcyBydWxlIHByb3RlY3RzIHlvdXIgYXBwbGljYXRpb24gYWdhaW5zdFxuICogY29tbW9uIGF0dGFja3MsIGluY2x1ZGluZyB0aGUgT1dBU1AgVG9wIDEwLlxuICpcbiAqIFRoZSBBcmNqZXQgU2hpZWxkIFdBRiBhbmFseXplcyBldmVyeSByZXF1ZXN0IHRvIHlvdXIgYXBwbGljYXRpb24gdG8gZGV0ZWN0XG4gKiBzdXNwaWNpb3VzIGFjdGl2aXR5LiBPbmNlIGEgY2VydGFpbiBzdXNwaWNpb24gdGhyZXNob2xkIGlzIHJlYWNoZWQsXG4gKiBzdWJzZXF1ZW50IHJlcXVlc3RzIGZyb20gdGhhdCBjbGllbnQgYXJlIGJsb2NrZWQgZm9yIGEgcGVyaW9kIG9mIHRpbWUuXG4gKlxuICogQHBhcmFtIHtTaGllbGRPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBTaGllbGQgcnVsZS5cbiAqIEBwYXJhbSB7QXJjamV0TW9kZX0gb3B0aW9ucy5tb2RlIC0gVGhlIGJsb2NrIG1vZGUgb2YgdGhlIHJ1bGUsIGVpdGhlclxuICogYFwiTElWRVwiYCBvciBgXCJEUllfUlVOXCJgLiBgXCJMSVZFXCJgIHdpbGwgYmxvY2sgc3VzcGljaW91cyByZXF1ZXN0cywgYW5kXG4gKiBgXCJEUllfUlVOXCJgIHdpbGwgYWxsb3cgYWxsIHJlcXVlc3RzIHdoaWxlIHN0aWxsIHByb3ZpZGluZyBhY2Nlc3MgdG8gdGhlIHJ1bGVcbiAqIHJlc3VsdHMuIERlZmF1bHRzIHRvIGBcIkRSWV9SVU5cImAgaWYgbm90IHNwZWNpZmllZC5cbiAqIEByZXR1cm5zIHtQcmltaXRpdmV9IFRoZSBTaGllbGQgcnVsZSB0byBwcm92aWRlIHRvIHRoZSBTREsgaW4gdGhlIGBydWxlc2BcbiAqIG9wdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIHNoaWVsZCh7IG1vZGU6IFwiTElWRVwiIH0pO1xuICogYGBgXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICBydWxlczogW3NoaWVsZCh7IG1vZGU6IFwiTElWRVwiIH0pXSxcbiAqIH0pO1xuICogYGBgXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9zaGllbGQvY29uY2VwdHNcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3NoaWVsZC9yZWZlcmVuY2VcbiAqL1xuZnVuY3Rpb24gc2hpZWxkKG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZVNoaWVsZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgdHlwZSA9IFwiU0hJRUxEXCI7XG4gICAgY29uc3QgdmVyc2lvbiA9IDA7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gXCJMSVZFXCIgPyBcIkxJVkVcIiA6IFwiRFJZX1JVTlwiO1xuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5TaGllbGQsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIHZhbGlkYXRlKCkgeyB9LFxuICAgICAgICBhc3luYyBwcm90ZWN0KGNvbnRleHQsIGRldGFpbHMpIHtcbiAgICAgICAgICAgIC8vIFRPRE8oIzE5ODkpOiBQcmVmZXIgY2hhcmFjdGVyaXN0aWNzIGRlZmluZWQgb24gcnVsZSBvbmNlIGF2YWlsYWJsZVxuICAgICAgICAgICAgY29uc3QgbG9jYWxDaGFyYWN0ZXJpc3RpY3MgPSBjb250ZXh0LmNoYXJhY3RlcmlzdGljcztcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVJZCA9IGF3YWl0IGhhc2hlci5oYXNoKGhhc2hlci5zdHJpbmcoXCJ0eXBlXCIsIHR5cGUpLCBoYXNoZXIudWludDMyKFwidmVyc2lvblwiLCB2ZXJzaW9uKSwgaGFzaGVyLnN0cmluZyhcIm1vZGVcIiwgbW9kZSksIGhhc2hlci5zdHJpbmdTbGljZU9yZGVyZWQoXCJjaGFyYWN0ZXJpc3RpY3NcIiwgbG9jYWxDaGFyYWN0ZXJpc3RpY3MpKTtcbiAgICAgICAgICAgIGNvbnN0IGFuYWx5emVDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGNoYXJhY3RlcmlzdGljczogbG9jYWxDaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgICAgICAgICAgbG9nOiBjb250ZXh0LmxvZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBmaW5nZXJwcmludCA9IGF3YWl0IGFuYWx5emUuZ2VuZXJhdGVGaW5nZXJwcmludChhbmFseXplQ29udGV4dCwgdG9BbmFseXplUmVxdWVzdChkZXRhaWxzKSk7XG4gICAgICAgICAgICBjb25zdCBbY2FjaGVkLCB0dGxdID0gYXdhaXQgY29udGV4dC5jYWNoZS5nZXQocnVsZUlkLCBmaW5nZXJwcmludCk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgdHRsLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJDQUNIRURcIixcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogY2FjaGVkLmNvbmNsdXNpb24sXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogY2FjaGVkLnJlYXNvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJOT1RfUlVOXCIsXG4gICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJBTExPV1wiLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldFNoaWVsZFJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgIHNoaWVsZFRyaWdnZXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBbcnVsZV07XG59XG4vKipcbiAqIEFyY2pldCBzaWdudXAgZm9ybSBwcm90ZWN0aW9uIHJ1bGUuIEFwcGx5aW5nIHRoaXMgcnVsZSBjb21iaW5lcyByYXRlXG4gKiBsaW1pdGluZywgYm90IHByb3RlY3Rpb24sIGFuZCBlbWFpbCB2YWxpZGF0aW9uIHRvIHByb3RlY3QgeW91ciBzaWdudXAgZm9ybXNcbiAqIGZyb20gYWJ1c2UuIFVzaW5nIHRoaXMgcnVsZSB3aWxsIGNvbmZpZ3VyZSB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gUmF0ZSBsaW1pdGluZyAtIHNpZ251cCBmb3JtcyBhcmUgYSBjb21tb24gdGFyZ2V0IGZvciBib3RzLiBBcmNqZXTigJlzIHJhdGVcbiAqICAgbGltaXRpbmcgaGVscHMgdG8gcHJldmVudCBib3RzIGFuZCBvdGhlciBhdXRvbWF0ZWQgb3IgbWFsaWNpb3VzIGNsaWVudHNcbiAqICAgZnJvbSBzdWJtaXR0aW5nIHlvdXIgc2lnbnVwIGZvcm0gdG9vIG1hbnkgdGltZXMgaW4gYSBzaG9ydCBwZXJpb2Qgb2YgdGltZS5cbiAqIC0gQm90IHByb3RlY3Rpb24gLSBzaWdudXAgZm9ybXMgYXJlIHVzdWFsbHkgZXhjbHVzaXZlbHkgdXNlZCBieSBodW1hbnMsIHdoaWNoXG4gKiAgIG1lYW5zIHRoYXQgYW55IGF1dG9tYXRlZCBzdWJtaXNzaW9ucyB0byB0aGUgZm9ybSBhcmUgbGlrZWx5IHRvIGJlXG4gKiAgIGZyYXVkdWxlbnQuXG4gKiAtIEVtYWlsIHZhbGlkYXRpb24gLSBlbWFpbCBhZGRyZXNzZXMgc2hvdWxkIGJlIHZhbGlkYXRlZCB0byBlbnN1cmUgdGhlIHNpZ251cFxuICogICBpcyBjb21pbmcgZnJvbSBhIGxlZ2l0aW1hdGUgdXNlciB3aXRoIGEgcmVhbCBlbWFpbCBhZGRyZXNzIHRoYXQgY2FuXG4gKiAgIGFjdHVhbGx5IHJlY2VpdmUgbWVzc2FnZXMuXG4gKlxuICogQHBhcmFtIHtQcm90ZWN0U2lnbnVwT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgc2lnbnVwIGZvcm1cbiAqIHByb3RlY3Rpb24gcnVsZS5cbiAqIEBwYXJhbSB7QXJjamV0TW9kZX0gb3B0aW9ucy5lbWFpbC5tb2RlIC0gVGhlIGJsb2NrIG1vZGUgb2YgdGhlIHJ1bGUsIGVpdGhlclxuICogYFwiTElWRVwiYCBvciBgXCJEUllfUlVOXCJgLiBgXCJMSVZFXCJgIHdpbGwgYmxvY2sgZW1haWwgYWRkcmVzc2VzIGJhc2VkIG9uIHRoZVxuICogY29uZmlndXJhdGlvbiwgYW5kIGBcIkRSWV9SVU5cImAgd2lsbCBhbGxvdyBhbGwgcmVxdWVzdHMgd2hpbGUgc3RpbGwgcHJvdmlkaW5nXG4gKiBhY2Nlc3MgdG8gdGhlIHJ1bGUgcmVzdWx0cy4gRGVmYXVsdHMgdG8gYFwiRFJZX1JVTlwiYCBpZiBub3Qgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtBcnJheTxBcmNqZXRFbWFpbFR5cGU+fSBvcHRpb25zLmVtYWlsLmRlbnkgLSBUaGUgbGlzdCBvZiBlbWFpbCB0eXBlc1xuICogdG8gZGVueS4gSWYgcHJvdmlkZWQsIHRoZSBlbWFpbCB0eXBlcyBpbiB0aGlzIGxpc3Qgd2lsbCBiZSBkZW5pZWQuIFlvdSBtYXlcbiAqIG9ubHkgcHJvdmlkZSBlaXRoZXIgYGFsbG93YCBvciBgZGVueWAsIG5vdCBib3RoLiBTcGVjaWZ5IG9uZSBvciBtb3JlIG9mIHRoZVxuICogZm9sbG93aW5nOlxuICpcbiAqIC0gYFwiRElTUE9TQUJMRVwiYCAtIERpc3Bvc2FibGUgZW1haWwgYWRkcmVzc2VzLlxuICogLSBgXCJGUkVFXCJgIC0gRnJlZSBlbWFpbCBhZGRyZXNzZXMuXG4gKiAtIGBcIk5PX01YX1JFQ09SRFNcImAgLSBFbWFpbCBhZGRyZXNzZXMgd2l0aCBubyBNWCByZWNvcmRzLlxuICogLSBgXCJOT19HUkFWQVRBUlwiYCAtIEVtYWlsIGFkZHJlc3NlcyB3aXRoIG5vIEdyYXZhdGFyLlxuICogLSBgXCJJTlZBTElEXCJgIC0gSW52YWxpZCBlbWFpbCBhZGRyZXNzZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcmNqZXRFbWFpbFR5cGU+fSBvcHRpb25zLmVtYWlsLmFsbG93IC0gVGhlIGxpc3Qgb2YgZW1haWwgdHlwZXNcbiAqIHRvIGFsbG93LiBJZiBwcm92aWRlZCwgZW1haWwgYWRkcmVzc2VzIGluIHRoaXMgbGlzdCB3aWxsIGJlIGFsbG93ZWQgYW5kIGFsbFxuICogb3RoZXJzIHdpbGwgYmUgZGVuaWVkLiBZb3UgbWF5IG9ubHkgcHJvdmlkZSBlaXRoZXIgYGFsbG93YCBvciBgZGVueWAsIG5vdFxuICogYm90aC4gVGhlIHNhbWUgb3B0aW9ucyBhcHBseSBhcyBmb3IgYGRlbnlgLlxuICogQHBhcmFtIHtBcmNqZXRNb2RlfSBvcHRpb25zLmJvdHMubW9kZSAtIFRoZSBibG9jayBtb2RlIG9mIHRoZSBydWxlLCBlaXRoZXJcbiAqIGBcIkxJVkVcImAgb3IgYFwiRFJZX1JVTlwiYC4gYFwiTElWRVwiYCB3aWxsIGJsb2NrIGRldGVjdGVkIGJvdHMsIGFuZCBgXCJEUllfUlVOXCJgXG4gKiB3aWxsIGFsbG93IGFsbCByZXF1ZXN0cyB3aGlsZSBzdGlsbCBwcm92aWRpbmcgYWNjZXNzIHRvIHRoZSBydWxlIHJlc3VsdHMuXG4gKiBEZWZhdWx0cyB0byBgXCJEUllfUlVOXCJgIGlmIG5vdCBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge0FycmF5PEFyY2pldFdlbGxLbm93bkJvdCB8IEFyY2pldEJvdENhdGVnb3J5Pn0gb3B0aW9ucy5ib3RzLmFsbG93IC1cbiAqIFRoZSBsaXN0IG9mIGJvdHMgdG8gYWxsb3cuIElmIHByb3ZpZGVkLCBvbmx5IHRoZSBib3RzIGluIHRoaXMgbGlzdCB3aWxsIGJlXG4gKiBhbGxvd2VkIGFuZCBhbnkgb3RoZXIgZGV0ZWN0ZWQgYm90IHdpbGwgYmUgZGVuaWVkLiBJZiBlbXB0eSwgYWxsIGJvdHMgd2lsbCBiZVxuICogZGVuaWVkLiBZb3UgbWF5IG9ubHkgcHJvdmlkZSBlaXRoZXIgYGFsbG93YCBvciBgZGVueWAsIG5vdCBib3RoLiBZb3UgY2FuIHVzZVxuICogc3BlY2lmaWMgYm90cyBlLmcuIGBcIkNVUkxcImAgd2lsbCBhbGxvdyB0aGUgZGVmYXVsdCB1c2VyLWFnZW50IG9mIHRoZSBgY3VybGBcbiAqIHRvb2wuIFlvdSBjYW4gYWxzbyB1c2UgY2F0ZWdvcmllcyBlLmcuIGBcIkNBVEVHT1JZOlNFQVJDSF9FTkdJTkVcImAgd2lsbCBhbGxvd1xuICogYWxsIHNlYXJjaCBlbmdpbmUgYm90cy4gU2VlXG4gKiBodHRwczovL2RvY3MuYXJjamV0LmNvbS9ib3QtcHJvdGVjdGlvbi9pZGVudGlmeWluZy1ib3RzIGZvciB0aGUgZnVsbCBsaXN0IG9mXG4gKiBib3RzIGFuZCBjYXRlZ29yaWVzLlxuICogQHBhcmFtIHtBcnJheTxBcmNqZXRXZWxsS25vd25Cb3QgfCBBcmNqZXRCb3RDYXRlZ29yeT59IG9wdGlvbnMuYm90cy5kZW55IC1cbiAqIFRoZSBsaXN0IG9mIGJvdHMgdG8gZGVueS4gSWYgcHJvdmlkZWQsIHRoZSBib3RzIGluIHRoaXMgbGlzdCB3aWxsIGJlIGRlbmllZFxuICogYW5kIGFsbCBvdGhlciBkZXRlY3RlZCBib3RzIHdpbGwgYmUgYWxsb3dlZC4gWW91IG1heSBvbmx5IHByb3ZpZGUgZWl0aGVyXG4gKiBgYWxsb3dgIG9yIGBkZW55YCwgbm90IGJvdGguIFRoZSBzYW1lIG9wdGlvbnMgYXBwbHkgYXMgZm9yIGBhbGxvd2AuXG4gKiBAcGFyYW0ge1NsaWRpbmdXaW5kb3dSYXRlTGltaXRPcHRpb25zfSBvcHRpb25zLnJhdGVMaW1pdCAtIFRoZSBvcHRpb25zIGZvclxuICogdGhlIHNsaWRpbmcgd2luZG93IHJhdGUgbGltaXRpbmcgcnVsZS5cbiAqIEBwYXJhbSB7QXJjamV0TW9kZX0gb3B0aW9ucy5yYXRlTGltaXQubW9kZSAtIFRoZSBibG9jayBtb2RlIG9mIHRoZSBydWxlLFxuICogZWl0aGVyIGBcIkxJVkVcImAgb3IgYFwiRFJZX1JVTlwiYC4gYFwiTElWRVwiYCB3aWxsIGJsb2NrIHJlcXVlc3RzIHdoZW4gdGhlIHJhdGVcbiAqIGxpbWl0IGlzIGV4Y2VlZGVkLCBhbmQgYFwiRFJZX1JVTlwiYCB3aWxsIGFsbG93IGFsbCByZXF1ZXN0cyB3aGlsZSBzdGlsbFxuICogcHJvdmlkaW5nIGFjY2VzcyB0byB0aGUgcnVsZSByZXN1bHRzLiBEZWZhdWx0cyB0byBgXCJEUllfUlVOXCJgIGlmIG5vdFxuICogc3BlY2lmaWVkLlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IG9wdGlvbnMucmF0ZUxpbWl0LmludGVydmFsIC0gVGhlIHRpbWUgaW50ZXJ2YWwgZm9yXG4gKiB0aGUgcmF0ZSBsaW1pdC4gVGhpcyBjYW4gYmUgYSBzdHJpbmcgbGlrZSBgXCI2MHNcImAgZm9yIDYwIHNlY29uZHMsIGBcIjFoNDVtXCJgXG4gKiBmb3IgMSBob3VyIGFuZCA0NSBtaW51dGVzLCBvciBhIG51bWJlciBsaWtlIGA2MGAgZm9yIDYwIHNlY29uZHMuIFZhbGlkIHN0cmluZ1xuICogdGltZSB1bml0cyBhcmU6XG4gKiAtIGBzYCBmb3Igc2Vjb25kcy5cbiAqIC0gYG1gIGZvciBtaW51dGVzLlxuICogLSBgaGAgZm9yIGhvdXJzLlxuICogLSBgZGAgZm9yIGRheXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5yYXRlTGltaXQubWF4IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlcXVlc3RzXG4gKiBhbGxvd2VkIGluIHRoZSBzbGlkaW5nIHRpbWUgd2luZG93LlxuICogQHJldHVybnMge1ByaW1pdGl2ZX0gVGhlIHNpZ251cCBmb3JtIHByb3RlY3Rpb24gcnVsZSB0byBwcm92aWRlIHRvIHRoZSBTREsgaW5cbiAqIHRoZSBgcnVsZXNgIG9wdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogT3VyIHJlY29tbWVuZGVkIGNvbmZpZ3VyYXRpb24gZm9yIG1vc3Qgc2lnbnVwIGZvcm1zIGlzOlxuICpcbiAqIC0gQmxvY2sgZW1haWxzIHdpdGggaW52YWxpZCBzeW50YXgsIHRoYXQgYXJlIGZyb20gZGlzcG9zYWJsZSBlbWFpbCBwcm92aWRlcnMsXG4gKiAgIG9yIGRvIG5vdCBoYXZlIHZhbGlkIE1YIHJlY29yZHMgY29uZmlndXJlZC5cbiAqIC0gQmxvY2sgYWxsIGJvdHMuXG4gKiAtIEFwcGx5IGEgcmF0ZSBsaW1pdCBvZiA1IHN1Ym1pc3Npb25zIHBlciAxMCBtaW51dGVzIGZyb20gYSBzaW5nbGUgSVBcbiAqICAgYWRkcmVzcy5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYWogPSBhcmNqZXQoe1xuICogICBrZXk6IHByb2Nlc3MuZW52LkFSQ0pFVF9LRVksXG4gKiAgIHJ1bGVzOiBbXG4gKiAgICBwcm90ZWN0U2lnbnVwKHtcbiAqICAgICAgZW1haWw6IHtcbiAqICAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgICBibG9jazogW1wiRElTUE9TQUJMRVwiLCBcIklOVkFMSURcIiwgXCJOT19NWF9SRUNPUkRTXCJdLFxuICogICAgICB9LFxuICogICAgICBib3RzOiB7XG4gKiAgICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICAgYWxsb3c6IFtdLCAvLyBibG9jayBhbGwgZGV0ZWN0ZWQgYm90c1xuICogICAgICB9LFxuICogICAgICByYXRlTGltaXQ6IHtcbiAqICAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgICBpbnRlcnZhbDogXCIxMG1cIixcbiAqICAgICAgICBtYXg6IDUsXG4gKiAgICAgIH0sXG4gKiAgICB9KSxcbiAqICBdLFxuICogfSk7XG4gKiBgYGBcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3NpZ251cC1wcm90ZWN0aW9uL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9zaWdudXAtcHJvdGVjdGlvbi9yZWZlcmVuY2VcbiAqL1xuZnVuY3Rpb24gcHJvdGVjdFNpZ251cChvcHRpb25zKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLi4uc2xpZGluZ1dpbmRvdyhvcHRpb25zLnJhdGVMaW1pdCksXG4gICAgICAgIC4uLmRldGVjdEJvdChvcHRpb25zLmJvdHMpLFxuICAgICAgICAuLi52YWxpZGF0ZUVtYWlsKG9wdGlvbnMuZW1haWwpLFxuICAgIF07XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBBcmNqZXQgY2xpZW50IHdpdGggdGhlIHNwZWNpZmllZCB7QGxpbmsgQXJjamV0T3B0aW9uc30uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge0FyY2pldE9wdGlvbnN9IEFyY2pldCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGFyY2pldChvcHRpb25zKSB7XG4gICAgLy8gV2UgZGVzdHJ1Y3R1cmUgaGVyZSB0byBtYWtlIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgbmVhdCB3aGVuIHZpZXdlZCBieSBjb25zdW1lcnNcbiAgICBjb25zdCB7IGtleSwgcnVsZXMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcnQgPSBydW50aW1lKCk7XG4gICAgLy8gVE9ETzogU2VwYXJhdGUgdGhlIEFyY2pldE9wdGlvbnMgZnJvbSB0aGUgU0RLIE9wdGlvbnNcbiAgICAvLyBJdCBpcyBjdXJyZW50bHkgb3B0aW9uYWwgaW4gdGhlIG9wdGlvbnMgc28gdXNlcnMgY2FuIG92ZXJyaWRlIGl0IHZpYSBhbiBTREtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9nID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvZyBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgbG9nID0gb3B0aW9ucy5sb2c7XG4gICAgY29uc3QgcGVyZiA9IG5ldyBQZXJmb3JtYW5jZShsb2cpO1xuICAgIC8vIFRPRE8oIzIwNyk6IFJlbW92ZSB0aGlzIHdoZW4gd2UgY2FuIGRlZmF1bHQgdGhlIHRyYW5zcG9ydCBzbyBjbGllbnQgaXMgbm90IHJlcXVpcmVkXG4gICAgLy8gSXQgaXMgY3VycmVudGx5IG9wdGlvbmFsIGluIHRoZSBvcHRpb25zIHNvIHRoZSBOZXh0IFNESyBjYW4gb3ZlcnJpZGUgaXQgZm9yIHRoZSB1c2VyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmNsaWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGllbnQgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudCA9IG9wdGlvbnMuY2xpZW50O1xuICAgIC8vIEEgbG9jYWwgY2FjaGUgb2YgYmxvY2sgZGVjaXNpb25zLiBNaWdodCBiZSBlbXBoZW1lcmFsIHBlciByZXF1ZXN0LFxuICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgd2F5IHRoZSBydW50aW1lIHdvcmtzLCBidXQgaXQncyB3b3J0aCBhIHRyeS5cbiAgICAvLyBUT0RPKCMxMzIpOiBTdXBwb3J0IGNvbmZpZ3VyYWJsZSBjYWNoaW5nXG4gICAgY29uc3QgY2FjaGUgPSBuZXcgTWVtb3J5Q2FjaGUoKTtcbiAgICBjb25zdCByb290UnVsZXMgPSBydWxlc1xuICAgICAgICAuZmxhdCgxKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIHByb3RlY3QocnVsZXMsIGN0eCwgcmVxdWVzdCkge1xuICAgICAgICAvLyBUaGlzIGdvZXMgYWdhaW5zdCB0aGUgdHlwZSBkZWZpbml0aW9uIGFib3ZlLCBidXQgdXNlcnMgbWlnaHQgY2FsbFxuICAgICAgICAvLyBgcHJvdGVjdCgpYCB3aXRoIG5vIHZhbHVlIGFuZCB3ZSBkb24ndCB3YW50IHRvIGNyYXNoXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmVxdWVzdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIGlwOiByZXF1ZXN0LmlwLFxuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHByb3RvY29sOiByZXF1ZXN0LnByb3RvY29sLFxuICAgICAgICAgICAgaG9zdDogcmVxdWVzdC5ob3N0LFxuICAgICAgICAgICAgcGF0aDogcmVxdWVzdC5wYXRoLFxuICAgICAgICAgICAgaGVhZGVyczogbmV3IEFyY2pldEhlYWRlcnMocmVxdWVzdC5oZWFkZXJzKSxcbiAgICAgICAgICAgIGNvb2tpZXM6IHJlcXVlc3QuY29va2llcyxcbiAgICAgICAgICAgIHF1ZXJ5OiByZXF1ZXN0LnF1ZXJ5LFxuICAgICAgICAgICAgZXh0cmE6IGV4dHJhUHJvcHMocmVxdWVzdCksXG4gICAgICAgICAgICBlbWFpbDogdHlwZW9mIHJlcXVlc3QuZW1haWwgPT09IFwic3RyaW5nXCIgPyByZXF1ZXN0LmVtYWlsIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyaXN0aWNzID0gb3B0aW9ucy5jaGFyYWN0ZXJpc3RpY3NcbiAgICAgICAgICAgID8gWy4uLm9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzXVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgY29uc3Qgd2FpdFVudGlsID0gbG9va3VwV2FpdFVudGlsKCk7XG4gICAgICAgIGNvbnN0IGJhc2VDb250ZXh0ID0ge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbG9nLFxuICAgICAgICAgICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICAgICAgd2FpdFVudGlsLFxuICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgZmluZ2VycHJpbnQgPSBcIlwiO1xuICAgICAgICBjb25zdCBsb2dGaW5nZXJwcmludFBlcmYgPSBwZXJmLm1lYXN1cmUoXCJmaW5nZXJwcmludFwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbmdlcnByaW50ID0gYXdhaXQgYW5hbHl6ZS5nZW5lcmF0ZUZpbmdlcnByaW50KGJhc2VDb250ZXh0LCB0b0FuYWx5emVSZXF1ZXN0KGRldGFpbHMpKTtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcImZpbmdlcnByaW50ICglcyk6ICVzXCIsIHJ0LCBmaW5nZXJwcmludCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoeyBlcnJvciB9LCBcIkZhaWxlZCB0byBidWlsZCBmaW5nZXJwcmludC4gUGxlYXNlIHZlcmlmeSB5b3VyIENoYXJhY3RlcmlzdGljcy5cIik7XG4gICAgICAgICAgICBjb25zdCBkZWNpc2lvbiA9IG5ldyBBcmNqZXRFcnJvckRlY2lzaW9uKHtcbiAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0RXJyb3JSZWFzb24oYEZhaWxlZCB0byBidWlsZCBmaW5nZXJwcmludCAtICR7ZXJyb3JNZXNzYWdlKGVycm9yKX1gKSxcbiAgICAgICAgICAgICAgICAvLyBObyByZXN1bHRzIGJlY2F1c2Ugd2UgY291bGRuJ3QgY3JlYXRlIGEgZmluZ2VycHJpbnRcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgc2VuZGluZyB0aGlzIHRvIFJlcG9ydCB3aGVuIHdlIGhhdmUgYW4gaW5mYWxsaWJsZSBmaW5nZXJwcmludFxuICAgICAgICAgICAgcmV0dXJuIGRlY2lzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgbG9nRmluZ2VycHJpbnRQZXJmKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dCA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgLi4uYmFzZUNvbnRleHQsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgcnVudGltZTogcnQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocnVsZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJDYWxsaW5nIGBwcm90ZWN0KClgIHdpdGggbm8gcnVsZXMgaXMgZGVwcmVjYXRlZC4gRGlkIHlvdSBtZWFuIHRvIGNvbmZpZ3VyZSB0aGUgU2hpZWxkIHJ1bGU/XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydWxlcy5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgbG9nLmVycm9yKFwiRmFpbHVyZSBydW5uaW5nIHJ1bGVzLiBPbmx5IDEwIHJ1bGVzIG1heSBiZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgICAgY29uc3QgZGVjaXNpb24gPSBuZXcgQXJjamV0RXJyb3JEZWNpc2lvbih7XG4gICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKFwiT25seSAxMCBydWxlcyBtYXkgYmUgc3BlY2lmaWVkXCIpLFxuICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdHMgYmVjYXVzZSB0aGUgc29ydGVkIHJ1bGVzIHdlcmUgdG9vIGxvbmcgYW5kIHdlIGRvbid0IHdhbnRcbiAgICAgICAgICAgICAgICAvLyB0byBpbnN0YW50aWF0ZSBhIHRvbiBvZiBOT1RfUlVOIHJlc3VsdHNcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xpZW50LnJlcG9ydChjb250ZXh0LCBkZXRhaWxzLCBkZWNpc2lvbiwgXG4gICAgICAgICAgICAvLyBObyBydWxlcyBiZWNhdXNlIHdlJ3ZlIGRldGVybWluZWQgdGhleSB3ZXJlIHRvbyBsb25nIGFuZCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gd2FudCB0byB0cnkgdG8gc2VuZCB0aGVtIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBkZWNpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHJ1bGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgYWxsIHJ1bGVzIHRvIE5PVF9SVU4vQUxMT1cgYmVmb3JlIGRvaW5nIGFueXRoaW5nXG4gICAgICAgICAgICByZXN1bHRzW2lkeF0gPSBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgLy8gVE9ETygjNDAzMCk6IEZpZ3VyZSBvdXQgaWYgd2UgY2FuIGdldCBlYWNoIFJ1bGUgSUQgYmVmb3JlIHRoZXkgYXJlIHJ1blxuICAgICAgICAgICAgICAgIHJ1bGVJZDogXCJcIixcbiAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgc3RhdGU6IFwiTk9UX1JVTlwiLFxuICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiQUxMT1dcIixcbiAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRSZWFzb24oKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQWRkIHRvcC1sZXZlbCBjaGFyYWN0ZXJpc3RpY3MgdG8gYWxsIFJhdGUgTGltaXQgcnVsZXMgdGhhdCBkb24ndCBhbHJlYWR5IGhhdmVcbiAgICAgICAgICAgIC8vIHRoZWlyIG93biBzZXQgb2YgY2hhcmFjdGVyaXN0aWNzLlxuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlX3J1bGUgPSBydWxlc1tpZHhdO1xuICAgICAgICAgICAgaWYgKGlzUmF0ZUxpbWl0UnVsZShjYW5kaWRhdGVfcnVsZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZV9ydWxlLmNoYXJhY3RlcmlzdGljcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVfcnVsZS5jaGFyYWN0ZXJpc3RpY3MgPSBjaGFyYWN0ZXJpc3RpY3M7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzW2lkeF0gPSBjYW5kaWRhdGVfcnVsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9nTG9jYWxQZXJmID0gcGVyZi5tZWFzdXJlKFwibG9jYWxcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZHgsIHJ1bGVdIG9mIHJ1bGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgcmUtYXNzaWdubWVudCBpcyBhIHdvcmthcm91bmQgdG8gYSBUeXBlU2NyaXB0IGVycm9yIHdpdGhcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnRpb25zIHdoZXJlIHRoZSBuYW1lIHdhcyBpbnRyb2R1Y2VkIHZpYSBhIGRlc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxSdWxlID0gcnVsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dSdWxlUGVyZiA9IHBlcmYubWVhc3VyZShydWxlLnR5cGUpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbG9jYWxSdWxlLnZhbGlkYXRlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJ1bGUgbXVzdCBoYXZlIGEgYHZhbGlkYXRlYCBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2NhbFJ1bGUudmFsaWRhdGUoY29udGV4dCwgZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbG9jYWxSdWxlLnByb3RlY3QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicnVsZSBtdXN0IGhhdmUgYSBgcHJvdGVjdGAgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpZHhdID0gYXdhaXQgbG9jYWxSdWxlLnByb3RlY3QoY29udGV4dCwgZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgcnVsZSBkaWRuJ3QgcmV0dXJuIGEgcnVsZSByZXN1bHQsIHdlIG5lZWQgdG8gc3R1YiBpdCB0byBhdm9pZFxuICAgICAgICAgICAgICAgICAgICAvLyBjcmFzaGluZy4gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgYSB1c2VyIHdyaXRlcyBhIGN1c3RvbSBsb2NhbFxuICAgICAgICAgICAgICAgICAgICAvLyBydWxlIGluY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdHNbaWR4XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpZHhdID0gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oIzQwMzApOiBJZiB3ZSBjYW4gZ2V0IHRoZSBSdWxlIElEIGJlZm9yZSBydW5uaW5nIHJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FuIHVzZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVJZDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiUlVOXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJFUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKFwicnVsZSByZXN1bHQgbWlzc2luZ1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1Zyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcmVzdWx0c1tpZHhdLnJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHJ1bGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZGV0YWlscy5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVudGltZTogcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0dGw6IHJlc3VsdHNbaWR4XS50dGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiByZXN1bHRzW2lkeF0uY29uY2x1c2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0c1tpZHhdLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgfSwgXCJMb2NhbCBydWxlIHJlc3VsdDpcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiRmFpbHVyZSBydW5uaW5nIHJ1bGU6ICVzIGR1ZSB0byAlc1wiLCBydWxlLnR5cGUsIGVycm9yTWVzc2FnZShlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpZHhdID0gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETygjNDAzMCk6IEZpZ3VyZSBvdXQgaWYgd2UgY2FuIGdldCBhIFJ1bGUgSUQgaW4gdGhpcyBlcnJvciBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlSWQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIlJVTlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJFUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0RXJyb3JSZWFzb24oZXJyKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBsb2dSdWxlUGVyZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2lkeF07XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc0RlbmllZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBydWxlIGlzIG5vdCBhIERSWV9SVU4sIHdlIHdhbnQgdG8gY2FjaGUgbm9uLXplcm8gVFRMIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHJldHVybiBhIERFTlkgZGVjaXNpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdGUgIT09IFwiRFJZX1JVTlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNpc2lvbiA9IG5ldyBBcmNqZXREZW55RGVjaXNpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR0bDogcmVzdWx0LnR0bCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlc3VsdC5yZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhIERFTlkgZGVjaXNpb24gaXMgcmVwb3J0ZWQgdG8gYXZvaWQgY3JlYXRpbmcgMiBlbnRyaWVzIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSByZXF1ZXN0LiBVcG9uIEFMTE9XLCB0aGUgYGRlY2lkZWAgY2FsbCB3aWxsIGNyZWF0ZSBhbiBlbnRyeSBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50LnJlcG9ydChjb250ZXh0LCBkZXRhaWxzLCBkZWNpc2lvbiwgcnVsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50dGwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQ6IHJlc3VsdC5maW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogcmVzdWx0LmNvbmNsdXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0LnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBcIkNhY2hpbmcgZGVjaXNpb24gZm9yICVkIHNlY29uZHNcIiwgZGVjaXNpb24udHRsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQocmVzdWx0LnJ1bGVJZCwgcmVzdWx0LmZpbmdlcnByaW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IHJlc3VsdC5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlc3VsdC5yZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVzdWx0LnR0bCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjaXNpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oYERyeSBydW4gbW9kZSBpcyBlbmFibGVkIGZvciBcIiVzXCIgcnVsZS4gT3ZlcnJpZGluZyBkZWNpc2lvbi4gRGVjaXNpb24gd2FzOiBERU5ZYCwgcnVsZS50eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBsb2dMb2NhbFBlcmYoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaXRoIG5vIGNhY2hlZCB2YWx1ZXMsIHdlIHRha2UgYSBkZWNpc2lvbiByZW1vdGVseS4gV2UgdXNlIGEgdGltZW91dCB0b1xuICAgICAgICAvLyBmYWlsIG9wZW4uXG4gICAgICAgIGNvbnN0IGxvZ1JlbW90ZVBlcmYgPSBwZXJmLm1lYXN1cmUoXCJyZW1vdGVcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBsb2dEZWRpY2VBcGlQZXJmID0gcGVyZi5tZWFzdXJlKFwiZGVjaWRlQXBpXCIpO1xuICAgICAgICAgICAgY29uc3QgZGVjaXNpb24gPSBhd2FpdCBjbGllbnRcbiAgICAgICAgICAgICAgICAuZGVjaWRlKGNvbnRleHQsIGRldGFpbHMsIHJ1bGVzKVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dEZWRpY2VBcGlQZXJmKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWNpc2lvbiBpcyB0byBibG9jayBhbmQgd2UgaGF2ZSBhIG5vbi16ZXJvIFRUTCwgd2UgY2FjaGUgdGhlXG4gICAgICAgICAgICAvLyBibG9jayBsb2NhbGx5XG4gICAgICAgICAgICBpZiAoZGVjaXNpb24uaXNEZW5pZWQoKSAmJiBkZWNpc2lvbi50dGwgPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiZGVjaWRlOiBDYWNoaW5nIGJsb2NrIGxvY2FsbHkgZm9yICVkIHNlY29uZHNcIiwgZGVjaXNpb24udHRsKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiBkZWNpc2lvbi5yZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGFsbCBERU5ZIHJlc3VsdHMgZm9yIGxvY2FsIGNhY2hlIGxvb2t1cHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5jb25jbHVzaW9uID09PSBcIkRFTllcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KHJlc3VsdC5ydWxlSWQsIHJlc3VsdC5maW5nZXJwcmludCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IHJlc3VsdC5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0LnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlc3VsdC50dGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY2lzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZy5pbmZvKFwiRW5jb3VudGVyZWQgcHJvYmxlbSBnZXR0aW5nIHJlbW90ZSBkZWNpc2lvbjogJXNcIiwgZXJyb3JNZXNzYWdlKGVycikpO1xuICAgICAgICAgICAgY29uc3QgZGVjaXNpb24gPSBuZXcgQXJjamV0RXJyb3JEZWNpc2lvbih7XG4gICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKGVyciksXG4gICAgICAgICAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xpZW50LnJlcG9ydChjb250ZXh0LCBkZXRhaWxzLCBkZWNpc2lvbiwgcnVsZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGRlY2lzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgbG9nUmVtb3RlUGVyZigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5XG4gICAgZnVuY3Rpb24gd2l0aFJ1bGUoYmFzZVJ1bGVzLCBydWxlKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gWy4uLmJhc2VSdWxlcywgLi4ucnVsZV0uc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICB3aXRoUnVsZShydWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhSdWxlKHJ1bGVzLCBydWxlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBwcm90ZWN0KGN0eCwgcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm90ZWN0KHJ1bGVzLCBjdHgsIHJlcXVlc3QpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgd2l0aFJ1bGUocnVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhSdWxlKHJvb3RSdWxlcywgcnVsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHByb3RlY3QoY3R4LCByZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvdGVjdChyb290UnVsZXMsIGN0eCwgcmVxdWVzdCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IGFyY2pldCBhcyBkZWZhdWx0LCBkZXRlY3RCb3QsIGZpeGVkV2luZG93LCBwcm90ZWN0U2lnbnVwLCBzZW5zaXRpdmVJbmZvLCBzaGllbGQsIHNsaWRpbmdXaW5kb3csIHRva2VuQnVja2V0LCB2YWxpZGF0ZUVtYWlsIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/arcjet/index.js\n");

/***/ })

};
;